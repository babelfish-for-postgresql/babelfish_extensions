-- tsql stype create function/procedure is not supported in postgres dialect
CREATE FUNCTION hi_func("@message" varchar(20)) RETURNS VOID AS BEGIN PRINT @message END;
ERROR:  syntax error at or near "BEGIN"
LINE 1: ...N hi_func("@message" varchar(20)) RETURNS VOID AS BEGIN PRIN...
                                                             ^
CREATE PROCEDURE hi_proc("@message" varchar(20)) AS BEGIN PRINT @message END;
ERROR:  syntax error at or near "BEGIN"
LINE 1: ...EATE PROCEDURE hi_proc("@message" varchar(20)) AS BEGIN PRIN...
                                                             ^
set babelfishpg_tsql.sql_dialect = "tsql";
-- it's supported in tsql dialect
CREATE FUNCTION hi_func("@message" varchar(20)) RETURNS VOID AS BEGIN PRINT @message END;
CREATE PROCEDURE hi_proc("@message" varchar(20)) AS BEGIN PRINT @message END;
-- PROC is also supported in tsql dialect
create proc proc_1 as print 'Hello World from Babel';
-- BABEL-219 typmod/length of sys.varchar works correctly in procudure parameter
call hi_proc('Hello World');
INFO:  Hello World
call proc_1();
INFO:  Hello World from Babel
-- clean up
drop function hi_func;
drop procedure hi_proc;
drop proc proc_1;
-- test executing pltsql function in postgres dialect
reset babelfishpg_tsql.sql_dialect;
CREATE OR REPLACE FUNCTION test_func() RETURNS int AS $$
BEGIN
	DECLARE @a int = 1;
	RETURN @a
END;
$$ LANGUAGE pltsql;
-- should be able execute a pltsql function in postgres dialect
show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 postgres
(1 row)

select test_func();
 test_func 
-----------
         1
(1 row)

show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 postgres
(1 row)

-- test executing pltsql trigger in postgres dialect
CREATE TABLE employees(
   id SERIAL PRIMARY KEY,
   first_name VARCHAR(40) NOT NULL,
   last_name VARCHAR(40) NOT NULL
);
CREATE TABLE employee_audits (
   id SERIAL PRIMARY KEY,
   employee_id INT NOT NULL,
   last_name VARCHAR(40) NOT NULL
);
CREATE OR REPLACE FUNCTION log_last_name_changes() RETURNS trigger AS $$
BEGIN
    IF NEW.last_name <> OLD.last_name THEN
         INSERT INTO employee_audits(employee_id,last_name)
         VALUES(OLD.id,OLD.last_name);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER last_name_changes
BEFORE UPDATE
ON employees
FOR EACH ROW
EXECUTE PROCEDURE log_last_name_changes();
INSERT INTO employees (first_name, last_name) VALUES ('A', 'B');
INSERT INTO employees (first_name, last_name) VALUES ('C', 'D');
SELECT * FROM employees;
 id | first_name | last_name 
----+------------+-----------
  1 | A          | B
  2 | C          | D
(2 rows)

show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 postgres
(1 row)

UPDATE employees SET last_name = 'E' WHERE ID = 2;
show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 postgres
(1 row)

SELECT * FROM employees;
 id | first_name | last_name 
----+------------+-----------
  1 | A          | B
  2 | C          | E
(2 rows)

SELECT * FROM employee_audits;
 id | employee_id | last_name 
----+-------------+-----------
  1 |           2 | D
(1 row)

-- test executing a plpgsql function in tsql dialect
CREATE OR REPLACE FUNCTION test_increment(i integer) RETURNS integer AS $$
BEGIN
	RETURN i + "1";
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION test_increment1(i integer) RETURNS integer AS $$
BEGIN
	RETURN i + CAST(n'1' AS varchar);
END;
$$ LANGUAGE plpgsql;
-- test that sql_dialect is restored even when the function has error in it
set babelfishpg_tsql.sql_dialect = "tsql";
show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 tsql
(1 row)

select test_increment(1);
ERROR:  column "1" does not exist
LINE 1: i + "1"
            ^
QUERY:  i + "1"
CONTEXT:  PL/pgSQL function test_increment(integer) line 3 at RETURN
show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 tsql
(1 row)

select test_increment1(1);
ERROR:  operator does not exist: integer + character varying
LINE 1: i + CAST(n'1' AS varchar)
          ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
QUERY:  i + CAST(n'1' AS varchar)
CONTEXT:  PL/pgSQL function test_increment1(integer) line 3 at RETURN
show babelfishpg_tsql.sql_dialect;
 babelfishpg_tsql.sql_dialect 
------------------------------
 tsql
(1 row)

-- test OBJECT_NAME function
select OBJECT_NAME('sys.columns'::regclass::Oid::int);
 object_name 
-------------
 columns
(1 row)

select OBJECT_NAME('boolin'::regproc::Oid::int);
 object_name 
-------------
 boolin
(1 row)

select OBJECT_NAME('int4'::regtype::Oid::int);
 object_name 
-------------
 int4
(1 row)

select OBJECT_NAME(1);
 object_name 
-------------
 
(1 row)

-- test SYSDATETIME function
-- Returns of type datetime2
select pg_typeof(SYSDATETIME());
 pg_typeof 
-----------
 datetime2
(1 row)

-- test GETDATE function
-- Returns of type datetime
select pg_typeof(GETDATE());
 pg_typeof 
-----------
 datetime
(1 row)

-- test current_timestamp function
select pg_typeof(current_timestamp);
 pg_typeof 
-----------
 datetime
(1 row)

-- test calling with parenthesis, should fail
select current_timestamp();
ERROR:  syntax error at or near ")"
LINE 1: select current_timestamp();
                                 ^
-- test CONVERT function
-- Conversion between varchar and date/time/datetime
select CONVERT(varchar(30), CAST('2017-08-25' AS date), 102);
 babelfish_conv_helper_to_varchar 
----------------------------------
 2017.08.25
(1 row)

select CONVERT(varchar(30), CAST('13:01:59' AS time), 8);
 babelfish_conv_helper_to_varchar 
----------------------------------
 13:01:59
(1 row)

select CONVERT(varchar(30), CAST('13:01:59' AS time), 22);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1:01:59 PM
(1 row)

select CONVERT(varchar(30), CAST('13:01:59' AS time), 22);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1:01:59 PM
(1 row)

select CONVERT(varchar(30), CAST('2017-08-25 13:01:59' AS datetime), 100);
 babelfish_conv_helper_to_varchar 
----------------------------------
 Aug 25 2017  1:01PM
(1 row)

select CONVERT(varchar(30), CAST('2017-08-25 13:01:59' AS datetime), 109);
 babelfish_conv_helper_to_varchar 
----------------------------------
 Aug 25 2017  1:01:59:000PM
(1 row)

select CONVERT(date, '08/25/2017', 101);
 babelfish_conv_helper_to_date 
-------------------------------
 08-25-2017
(1 row)

select CONVERT(time, '12:01:59', 101);
 babelfish_conv_helper_to_time 
-------------------------------
 12:01:59
(1 row)

select CONVERT(datetime, '2017-08-25 01:01:59PM', 120);
 babelfish_conv_helper_to_datetime 
-----------------------------------
 Fri Aug 25 13:01:59 2017
(1 row)

select CONVERT(varchar, CONVERT(datetime2(7), '9999-12-31 23:59:59.9999999'));
WARNING:  TIMESTAMP(7) precision reduced to maximum allowed, 6
WARNING:  TIMESTAMP(7) precision reduced to maximum allowed, 6
LINE 1: select CONVERT(varchar, CONVERT(datetime2(7), '9999-12-31 23...
                                        ^
 babelfish_conv_helper_to_varchar 
----------------------------------
 Fri Dec 31 23:59:59.999999 999
(1 row)

-- Conversion from float to varchar
select CONVERT(varchar(30), 11234561231231.234::float, 0);
 babelfish_conv_helper_to_varchar 
----------------------------------
 1.12346e+13                   
(1 row)

select CONVERT(varchar(30), 11234561231231.234::float, 1);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1.1234561e+13                
(1 row)

select CONVERT(varchar(30), 11234561231231.234::float, 2);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1.123456123123123e+13        
(1 row)

select CONVERT(varchar(30), 11234561231231.234::float, 3);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1.1234561231231234e+13       
(1 row)

-- Conversion from money to varchar
select CONVERT(varchar(10), CAST(4936.56 AS MONEY), 0);
 babelfish_conv_helper_to_varchar 
----------------------------------
  4936.56  
(1 row)

select CONVERT(varchar(10), CAST(4936.56 AS MONEY), 1);
 babelfish_conv_helper_to_varchar 
----------------------------------
 4,936.56  
(1 row)

select CONVERT(varchar(10), CAST(4936.56 AS MONEY), 2);
 babelfish_conv_helper_to_varchar 
----------------------------------
  4936.5600
(1 row)

select CONVERT(varchar(10), CAST(-4936.56 AS MONEY), 0);
 babelfish_conv_helper_to_varchar 
----------------------------------
 -4936.56  
(1 row)

-- Floor conversion to smallint, int, bigint
SELECT CONVERT(int, 99.9);
 int4 
------
   99
(1 row)

SELECT CONVERT(smallint, 99.9);
 int2 
------
   99
(1 row)

SELECT CONVERT(bigint, 99.9);
 int8 
------
   99
(1 row)

SELECT CONVERT(int, -99.9);
 int4 
------
  -99
(1 row)

SELECT CONVERT(int, '99');
 int4 
------
   99
(1 row)

SELECT CONVERT(int, CAST(99.9 AS double precision));
 int4 
------
   99
(1 row)

SELECT CONVERT(int, CAST(99.9 AS real));
 int4 
------
   99
(1 row)

-- test TRY_CONVERT function
-- Conversion between different types and varchar
select TRY_CONVERT(varchar(30), CAST('2017-08-25' AS date), 102);
 babelfish_conv_helper_to_varchar 
----------------------------------
 2017.08.25
(1 row)

select TRY_CONVERT(varchar(30), CAST('13:01:59' AS time), 8);
 babelfish_conv_helper_to_varchar 
----------------------------------
 13:01:59
(1 row)

select TRY_CONVERT(varchar(30), CAST('13:01:59' AS time), 22);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1:01:59 PM
(1 row)

select TRY_CONVERT(varchar(30), CAST('2017-08-25 13:01:59' AS datetime), 109);
 babelfish_conv_helper_to_varchar 
----------------------------------
 Aug 25 2017  1:01:59:000PM
(1 row)

select TRY_CONVERT(varchar(30), 11234561231231.234::float, 0);
 babelfish_conv_helper_to_varchar 
----------------------------------
 1.12346e+13                   
(1 row)

select TRY_CONVERT(varchar(30), 11234561231231.234::float, 1);
 babelfish_conv_helper_to_varchar 
----------------------------------
  1.1234561e+13                
(1 row)

select TRY_CONVERT(varchar(10), CAST(4936.56 AS MONEY), 0);
 babelfish_conv_helper_to_varchar 
----------------------------------
  4936.56  
(1 row)

-- Wrong conversions that return NULL
select TRY_CONVERT(date, 123);
 babelfish_conv_helper_to_date 
-------------------------------
 
(1 row)

select TRY_CONVERT(time, 123);
 babelfish_conv_helper_to_time 
-------------------------------
 
(1 row)

select TRY_CONVERT(datetime, 123);
 babelfish_conv_helper_to_datetime 
-----------------------------------
 
(1 row)

select TRY_CONVERT(money, 'asdf');
 babelfish_try_cast_to_any 
---------------------------
 
(1 row)

-- test PARSE function
-- Conversion from string to date/time/datetime
select PARSE('2017-08-25' AS date);
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select PARSE('2017-08-25' AS date USING 'Cs-CZ');
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select PARSE('08/25/2017' AS date USING 'en-US');
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select PARSE('25/08/2017' AS date USING 'de-DE');
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select PARSE('13:01:59' AS time);
 babelfish_parse_helper_to_time 
--------------------------------
 13:01:59
(1 row)

select PARSE('13:01:59' AS time USING 'en-US');
 babelfish_parse_helper_to_time 
--------------------------------
 13:01:59
(1 row)

select PARSE('13:01:59' AS time USING 'zh-CN');
 babelfish_parse_helper_to_time 
--------------------------------
 13:01:59
(1 row)

select PARSE('2017-08-25 13:01:59' AS datetime);
 babelfish_parse_helper_to_datetime 
------------------------------------
 Fri Aug 25 13:01:59 2017
(1 row)

select PARSE('2017-08-25 13:01:59' AS datetime USING 'zh-CN');
 babelfish_parse_helper_to_datetime 
------------------------------------
 Fri Aug 25 13:01:59 2017
(1 row)

select PARSE('12:01:59' AS time);
 babelfish_parse_helper_to_time 
--------------------------------
 12:01:59
(1 row)

select PARSE('2017-08-25 01:01:59PM' AS datetime);
 babelfish_parse_helper_to_datetime 
------------------------------------
 Fri Aug 25 13:01:59 2017
(1 row)

-- Test if unnecessary culture arg given
select PARSE('123' AS int USING 'de-DE');
 int4 
------
  123
(1 row)

-- test TRY_PARSE function
-- Expect null return on error
-- Conversion from string to date/time/datetime
select TRY_PARSE('2017-08-25' AS date);
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select TRY_PARSE('2017-08-25' AS date USING 'Cs-CZ');
 babelfish_parse_helper_to_date 
--------------------------------
 08-25-2017
(1 row)

select TRY_PARSE('789' AS date USING 'en-US');
 babelfish_parse_helper_to_date 
--------------------------------
 
(1 row)

select TRY_PARSE('asdf' AS date USING 'de-DE');
 babelfish_parse_helper_to_date 
--------------------------------
 
(1 row)

select TRY_PARSE('13:01:59' AS time);
 babelfish_parse_helper_to_time 
--------------------------------
 13:01:59
(1 row)

select TRY_PARSE('asdf' AS time USING 'en-US');
 babelfish_parse_helper_to_time 
--------------------------------
 
(1 row)

select TRY_PARSE('13-12-21' AS time USING 'zh-CN');
 babelfish_parse_helper_to_time 
--------------------------------
 00:00:00
(1 row)

select TRY_PARSE('2017-08-25 13:01:59' AS datetime);
 babelfish_parse_helper_to_datetime 
------------------------------------
 Fri Aug 25 13:01:59 2017
(1 row)

select TRY_PARSE('20asdf17' AS datetime USING 'de-DE');
 babelfish_parse_helper_to_datetime 
------------------------------------
 
(1 row)

-- Wrong conversions that return NULL
select TRY_PARSE('asdf' AS numeric(3,2));
 babelfish_try_cast_to_any 
---------------------------
                          
(1 row)

select TRY_PARSE('123' AS datetime2);
 babelfish_try_cast_to_any 
---------------------------
 
(1 row)

select TRY_PARSE('asdf' AS MONEY);
 babelfish_try_cast_to_any 
---------------------------
 
(1 row)

select TRY_PARSE('asdf' AS int USING 'de-DE');
 babelfish_try_cast_floor_int 
------------------------------
                             
(1 row)

-- test serverproperty() function
-- invalid property name, should reutnr NULL
select serverproperty(n'invalid property');
 serverproperty 
----------------
 
(1 row)

-- valid supported properties
select serverproperty(n'collation');
        serverproperty        
------------------------------
 sql_latin1_general_cp1_ci_as
(1 row)

select serverproperty(n'collationId');
 serverproperty 
----------------
 0
(1 row)

select serverproperty(n'IsSingleUser');
 serverproperty 
----------------
 0
(1 row)

select serverproperty(n'ServerName');
 serverproperty 
----------------
 BABELFISH
(1 row)

-- test ISDATE function
-- test valid argument
SELECT ISDATE('12/26/2016');
 isdate 
--------
      1
(1 row)

SELECT ISDATE('12-26-2016');
 isdate 
--------
      1
(1 row)

SELECT ISDATE('12.26.2016');
 isdate 
--------
      1
(1 row)

SELECT ISDATE('2016-12-26 23:30:05.523456');
 isdate 
--------
      1
(1 row)

-- test invalid argument
SELECT ISDATE('02/30/2016');
 isdate 
--------
      0
(1 row)

SELECT ISDATE('12/32/2016');
 isdate 
--------
      0
(1 row)

SELECT ISDATE('1995-10-1a');
 isdate 
--------
      0
(1 row)

SELECT ISDATE(NULL);
 isdate 
--------
      0
(1 row)

-- test DATEFROMPARTS function
-- test valid arguments
select datefromparts(2020,12,31);
 datefromparts 
---------------
 12-31-2020
(1 row)

-- test invalid arguments, should fail
select datefromparts(2020, 2, 30);
ERROR:  date field value out of range: 2020-02-30
CONTEXT:  SQL function "datefromparts" statement 1
select datefromparts(2020, 13, 1);
ERROR:  date field value out of range: 2020-13-01
CONTEXT:  SQL function "datefromparts" statement 1
select datefromparts(-4, 3, 150);
ERROR:  date field value out of range: -3-03-150
CONTEXT:  SQL function "datefromparts" statement 1
select datefromparts(10, 55, 10.1);
ERROR:  date field value out of range: 10-55-10
select datefromparts('2020', 55, 100.1);
ERROR:  date field value out of range: 2020-55-100
-- test DATETIMEFROMPARTS function
-- test valid arguments
select datetimefromparts(2016, 12, 26, 23, 30, 5, 32);
      datetimefromparts       
------------------------------
 Mon Dec 26 23:30:05.033 2016
(1 row)

select datetimefromparts(2016.0, 12, 26, 23, 30, 5, 32);
      datetimefromparts       
------------------------------
 Mon Dec 26 23:30:05.033 2016
(1 row)

select datetimefromparts(2016.1, 12, 26, 23, 30, 5, 32);
      datetimefromparts       
------------------------------
 Mon Dec 26 23:30:05.033 2016
(1 row)

select datetimefromparts(2016, 12, 26.99, 23, 30, 5, 32);
      datetimefromparts       
------------------------------
 Mon Dec 26 23:30:05.033 2016
(1 row)

select datetimefromparts(2016, 12.90, 26, 23, 30, 5, 32);
      datetimefromparts       
------------------------------
 Mon Dec 26 23:30:05.033 2016
(1 row)

-- test invalid arguments
select datetimefromparts(2016, 2, 30, 23, 30, 5, 32);
ERROR:  date field value out of range: 2016-02-30
CONTEXT:  PL/pgSQL function sys.datetimefromparts(numeric,numeric,numeric,numeric,numeric,numeric,numeric) line 29 at assignment
select datetimefromparts(2016, 12, 26, 23, 30, 5);
ERROR:  The datetimefromparts function requires 7 arguments
LINE 1: select datetimefromparts(2016, 12, 26, 23, 30, 5);
               ^
select datetimefromparts(2016, 12, 26, 23, 30, 5, NULL);
 datetimefromparts 
-------------------
 
(1 row)

-- test DATEPART function
-- test all valid datepart arguments
select datepart(year, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
     2016
(1 row)

select datepart(yyyy, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
     2016
(1 row)

select datepart(yy, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
     2016
(1 row)

select datepart(quarter, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        4
(1 row)

select datepart(qq, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        4
(1 row)

select datepart(q, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        4
(1 row)

select datepart(month, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       12
(1 row)

select datepart(mm, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       12
(1 row)

select datepart(m, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       12
(1 row)

select datepart(dayofyear, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      361
(1 row)

select datepart(dy, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      361
(1 row)

select datepart(day, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       26
(1 row)

select datepart(dd, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       26
(1 row)

select datepart(d, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       26
(1 row)

select datepart(week, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       53
(1 row)

select datepart(wk, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       53
(1 row)

select datepart(ww, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       53
(1 row)

select datepart(weekday, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        2
(1 row)

select datepart(dw, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        2
(1 row)

select datepart(hour, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       15
(1 row)

select datepart(hh, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       15
(1 row)

select datepart(minute, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       30
(1 row)

select datepart(n, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       30
(1 row)

select datepart(second, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        5
(1 row)

select datepart(ss, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        5
(1 row)

select datepart(s, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
        5
(1 row)

select datepart(millisecond, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      456
(1 row)

select datepart(ms, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      456
(1 row)

select datepart(microsecond, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
   523456
(1 row)

select datepart(mcs, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
   523456
(1 row)

select datepart(nanosecond, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart  
-----------
 523456000
(1 row)

select datepart(ns, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart  
-----------
 523456000
(1 row)

select datepart(tzoffset, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      480
(1 row)

select datepart(tz, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
      480
(1 row)

select datepart(iso_week, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       52
(1 row)

select datepart(isowk, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       52
(1 row)

select datepart(isoww, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datepart 
----------
       52
(1 row)

-- test different types of date/time arguments
select datepart(month, '2016-12-26 23:30:05.523'::sys.datetime);
 datepart 
----------
       12
(1 row)

select datepart(quarter, '2016-12-26 23:30:05.523456'::datetime2);
 datepart 
----------
        4
(1 row)

select datepart(hour, '2016-12-26 23:30:05'::smalldatetime);
 datepart 
----------
       23
(1 row)

select datepart(dayofyear, '2016-12-26'::date);
 datepart 
----------
      361
(1 row)

select datepart(second, '04:12:34.876543'::time);
 datepart 
----------
       34
(1 row)

-- test edge cases: try to get datepart that does not exist in the argument
select datepart(year, cast('12:10:30.123' as time));
 datepart 
----------
     1900
(1 row)

select datepart(yyyy, cast('12:10:30.123' as time));
 datepart 
----------
     1900
(1 row)

select datepart(yy, cast('12:10:30.123' as time));
 datepart 
----------
     1900
(1 row)

select datepart(quarter, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(qq, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(q, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(month, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(mm, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(m, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(dayofyear, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(dy, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(y, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(day, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(dd, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(d, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(week, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(wk, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(ww, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(weekday, cast('12:10:30.123' as time));
 datepart 
----------
        2
(1 row)

select datepart(dw, cast('12:10:30.123' as time));
 datepart 
----------
        2
(1 row)

select datepart(tzoffset, cast('12:10:30.123' as time));
 datepart 
----------
        0
(1 row)

select datepart(tz, cast('12:10:30.123' as time));
 datepart 
----------
        0
(1 row)

select datepart(iso_week, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(isowk, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(isoww, cast('12:10:30.123' as time));
 datepart 
----------
        1
(1 row)

select datepart(hour, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(hh, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(minute, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(n, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(second, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(ss, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(s, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(millisecond, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(ms, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(microsecond, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(mcs, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(nanosecond, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

select datepart(ns, cast('2016-12-26' as date));
 datepart 
----------
        0
(1 row)

-- test invalid interval, expect error
select datepart(invalid_interval, cast('2016-12-26 23:30:05.523456' as date));
ERROR:  'invalid_interval' is not a recognized datepart option
CONTEXT:  PL/pgSQL function sys.datepart_internal(text,anyelement,integer) line 66 at RAISE
PL/pgSQL function sys.datepart(text,anyelement) line 7 at RETURN
select datepart(invalidinterval, cast('12:10:30.123' as time));
ERROR:  'invalidinterval' is not a recognized datepart option
CONTEXT:  PL/pgSQL function sys.datepart_internal(text,anyelement,integer) line 66 at RAISE
PL/pgSQL function sys.datepart(text,anyelement) line 7 at RETURN
-- test DATENAME function
select datename(year, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 2016
(1 row)

select datename(dd, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 26
(1 row)

select datename(weekday, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 Monday
(1 row)

select datename(dw, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 Monday
(1 row)

select datename(month, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 December
(1 row)

select datename(mm, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 December
(1 row)

select datename(m, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 December
(1 row)

select datename(isowk, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
 datename 
----------
 52
(1 row)

-- test invalid argument, expect error
select datename(invalid_interval, cast('2016-12-26 23:30:05.523456' as date));
ERROR:  'invalid_interval' is not a recognized datepart option
CONTEXT:  PL/pgSQL function sys.datepart_internal(text,anyelement,integer) line 66 at RAISE
PL/pgSQL function sys.datepart(text,anyelement) line 7 at RETURN
SQL function "datename" statement 1
-- test DATEFIRST option, together DATEPART function
-- This shows the return value for the week and weekday datepart for '2007-04-21' for each SET DATEFIRST argument.
-- January 1, 2007 falls on a Monday. April 21, 2007 falls on a Saturday.
-- DATEFIRST week weekday
-- 1	16	6
-- 2	17	5
-- 3	17	4
-- 4	17	3
-- 5	17	2
-- 6	17	1
-- 7	16	7
select @@datefirst;
 datefirst 
-----------
         7
(1 row)

set datefirst 1;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       16 |        6
(1 row)

set datefirst 2;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       17 |        5
(1 row)

set datefirst 3;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       17 |        4
(1 row)

set datefirst 4;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       17 |        3
(1 row)

set datefirst 5;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       17 |        2
(1 row)

set datefirst 6;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       17 |        1
(1 row)

set datefirst 7;
select datepart(week, '2007-04-21'::date), datepart(weekday, '2007-04-21'::date);
 datepart | datepart 
----------+----------
       16 |        7
(1 row)

-- test edge case: date within the week of Jan. 1st
select datepart(week, '2007-01-01'::date), datepart(weekday, '2007-01-01'::date);
 datepart | datepart 
----------+----------
        1 |        2
(1 row)

select datepart(week, '2007-01-02'::date), datepart(weekday, '2007-01-02'::date);
 datepart | datepart 
----------+----------
        1 |        3
(1 row)

select datepart(week, '2007-01-03'::date), datepart(weekday, '2007-01-03'::date);
 datepart | datepart 
----------+----------
        1 |        4
(1 row)

select datepart(week, '2007-01-04'::date), datepart(weekday, '2007-01-04'::date);
 datepart | datepart 
----------+----------
        1 |        5
(1 row)

select datepart(week, '2007-01-05'::date), datepart(weekday, '2007-01-05'::date);
 datepart | datepart 
----------+----------
        1 |        6
(1 row)

select datepart(week, '2007-01-06'::date), datepart(weekday, '2007-01-06'::date);
 datepart | datepart 
----------+----------
        1 |        7
(1 row)

-- test edge case: date just outside the week of Jan. 1st
select datepart(week, '2007-01-07'::date), datepart(weekday, '2007-01-07'::date);
 datepart | datepart 
----------+----------
        2 |        1
(1 row)

-- test DATEDIFF function
select datediff(year, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
       -1
(1 row)

select datediff(quarter, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
       -4
(1 row)

select datediff(month, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
      -13
(1 row)

select datediff(dayofyear, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
     -367
(1 row)

select datediff(day, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
     -367
(1 row)

select datediff(week, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
      -52
(1 row)

select datediff(hour, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
    -8808
(1 row)

select datediff(minute, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff 
----------
  -528480
(1 row)

select datediff(second, '2037-03-01 23:30:05.523'::sys.datetime, '2036-02-28 23:30:05.523'::sys.datetime);
 datediff  
-----------
 -31708800
(1 row)

select datediff(millisecond, '2036-02-28 01:23:45.234'::sys.datetime, '2036-02-28 01:23:45.123'::sys.datetime);
 datediff 
----------
     -111
(1 row)

select datediff(microsecond, '2036-02-28 01:23:45.234'::sys.datetime, '2036-02-28 01:23:45.123'::sys.datetime);
 datediff 
----------
  -111000
(1 row)

select datediff(nanosecond, '2036-02-28 01:23:45.234'::sys.datetime, '2036-02-28 01:23:45.123'::sys.datetime);
  datediff  
------------
 -111000000
(1 row)

-- test different types of date/time arguments
select datediff(minute, '2016-12-26 23:30:05.523456+8'::datetimeoffset, '2016-12-31 23:30:05.523456+8'::datetimeoffset);
 datediff 
----------
     7200
(1 row)

select datediff(quarter, '2016-12-26 23:30:05.523456'::datetime2, '2018-08-31 23:30:05.523456'::datetime2);
 datediff 
----------
        6
(1 row)

select datediff(hour, '2016-12-26 23:30:05'::smalldatetime, '2016-12-28 21:29:05'::smalldatetime);
 datediff 
----------
       45
(1 row)

select datediff(year, '2037-03-01'::date, '2036-02-28'::date);
 datediff 
----------
       -1
(1 row)

-- test DATEADD function
select dateadd(year, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Sat Aug 30 00:00:00 2008
(1 row)

select dateadd(quarter, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Feb 28 00:00:00 2007
(1 row)

select dateadd(month, 1, '20060831'::datetime);
         dateadd          
--------------------------
 Sat Sep 30 00:00:00 2006
(1 row)

select dateadd(dayofyear, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Fri Sep 01 00:00:00 2006
(1 row)

select dateadd(day, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Fri Sep 01 00:00:00 2006
(1 row)

select dateadd(week, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Sep 13 00:00:00 2006
(1 row)

select dateadd(weekday, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Fri Sep 01 00:00:00 2006
(1 row)

select dateadd(hour, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Aug 30 02:00:00 2006
(1 row)

select dateadd(minute, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Aug 30 00:02:00 2006
(1 row)

select dateadd(second, 2, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Aug 30 00:00:02 2006
(1 row)

select dateadd(millisecond, 123, '20060830'::datetime);
           dateadd            
------------------------------
 Wed Aug 30 00:00:00.123 2006
(1 row)

select dateadd(microsecond, 123456, '20060830'::datetime);
           dateadd            
------------------------------
 Wed Aug 30 00:00:00.123 2006
(1 row)

select dateadd(nanosecond, 123456, '20060830'::datetime);
         dateadd          
--------------------------
 Wed Aug 30 00:00:00 2006
(1 row)

-- test different types of date/time arguments
select dateadd(hour, 2, '23:12:34.876543'::time);
     dateadd     
-----------------
 01:12:34.876543
(1 row)

select dateadd(quarter, 3, '2037-03-01'::date);
  dateadd   
------------
 12-01-2037
(1 row)

select dateadd(minute, 70, '2016-12-26 23:30:05.523456+8'::datetimeoffset);
                dateadd                 
----------------------------------------
 Mon Dec 26 16:40:05.523456 2016 +08:00
(1 row)

select dateadd(month, 2, '2016-12-26 23:30:05.523456'::datetime2);
             dateadd             
---------------------------------
 Sun Feb 26 23:30:05.523456 2017
(1 row)

select dateadd(second, 56, '2016-12-26 23:30:05'::smalldatetime);
         dateadd          
--------------------------
 Mon Dec 26 23:31:00 2016
(1 row)

-- test negative argument
select dateadd(year, -2, '20060830'::datetime);
         dateadd          
--------------------------
 Mon Aug 30 00:00:00 2004
(1 row)

select dateadd(month, -20, '2016-12-26 23:30:05.523456'::datetime2);
             dateadd             
---------------------------------
 Sun Apr 26 23:30:05.523456 2015
(1 row)

select dateadd(hour, -2, '01:12:34.876543'::time);
     dateadd     
-----------------
 23:12:34.876543
(1 row)

select dateadd(minute, -70, '2016-12-26 00:30:05.523456+8'::datetimeoffset);
                dateadd                 
----------------------------------------
 Sun Dec 25 15:20:05.523456 2016 +08:00
(1 row)

select dateadd(second, -56, '2016-12-26 00:00:55'::smalldatetime);
         dateadd          
--------------------------
 Mon Dec 26 00:00:00 2016
(1 row)

-- test return type
select pg_typeof(dateadd(hour, -2, '01:12:34.876543'::time));
       pg_typeof        
------------------------
 time without time zone
(1 row)

select pg_typeof(dateadd(second, -56, '2016-12-26 00:00:55'::smalldatetime));
   pg_typeof   
---------------
 smalldatetime
(1 row)

select pg_typeof(dateadd(year, -2, '20060830'::datetime));
 pg_typeof 
-----------
 datetime
(1 row)

select pg_typeof(dateadd(month, -20, '2016-12-26 23:30:05.523456'::datetime2));
 pg_typeof 
-----------
 datetime2
(1 row)

select pg_typeof(dateadd(minute, -70, '2016-12-26 00:30:05.523456+8'::datetimeoffset));
   pg_typeof    
----------------
 datetimeoffset
(1 row)

-- test illegal usage
select dateadd(minute, 2, '2037-03-01'::date);
ERROR:  The datepart minute is not supported by date function dateadd for data type date.
CONTEXT:  PL/pgSQL function sys.dateadd_internal(text,integer,anyelement) line 5 at RAISE
PL/pgSQL function sys.dateadd(text,integer,anyelement) line 7 at RETURN
select dateadd(day, 4, '04:12:34.876543'::time);
ERROR:  The datepart day is not supported by date function dateadd for data type time.
CONTEXT:  PL/pgSQL function sys.dateadd_internal(text,integer,anyelement) line 9 at RAISE
PL/pgSQL function sys.dateadd(text,integer,anyelement) line 7 at RETURN
-- test using variables, instead of constants, for the second parameter
create table dateadd_table(a int, b datetime);
insert into dateadd_table values(1, '2020-10-29'::datetime);
select * from dateadd_table;
 a |            b             
---+--------------------------
 1 | Thu Oct 29 00:00:00 2020
(1 row)

update dateadd_table set b = dateadd(dd, a, '2020-10-30'::datetime);
select * from dateadd_table;
 a |            b             
---+--------------------------
 1 | Sat Oct 31 00:00:00 2020
(1 row)

create procedure dateadd_procedure as
begin
	declare @d int = 1
	update dateadd_table set b = dateadd(dd, @d, CAST('2020-10-31' AS datetime))
end;
call dateadd_procedure();
select * from dateadd_table;
 a |            b             
---+--------------------------
 1 | Sun Nov 01 00:00:00 2020
(1 row)

-- test CHARINDEX function
select CHARINDEX('hello', 'hello world');
 charindex 
-----------
         1
(1 row)

select CHARINDEX('hello  ', 'hello world');
 charindex 
-----------
         0
(1 row)

select CHARINDEX('hello world', 'hello');
 charindex 
-----------
         0
(1 row)

-- test NULL input
select CHARINDEX(NULL, NULL);
 charindex 
-----------
          
(1 row)

select CHARINDEX(NULL, 'string');
 charindex 
-----------
          
(1 row)

select CHARINDEX('pattern', NULL);
 charindex 
-----------
          
(1 row)

select CHARINDEX('pattern', 'string', NULL);
 charindex 
-----------
          
(1 row)

-- test start_location parameter
select CHARINDEX('hello', 'hello world', -1);
 charindex 
-----------
         1
(1 row)

select CHARINDEX('hello', 'hello world', 0);
 charindex 
-----------
         1
(1 row)

select CHARINDEX('hello', 'hello world', 1);
 charindex 
-----------
         1
(1 row)

select CHARINDEX('hello', 'hello world', 2);
 charindex 
-----------
         0
(1 row)

select CHARINDEX('world', 'hello world', 6);
 charindex 
-----------
         7
(1 row)

select CHARINDEX('world', 'hello world', 7);
 charindex 
-----------
         7
(1 row)

select CHARINDEX('world', 'hello world', 8);
 charindex 
-----------
         0
(1 row)

select CHARINDEX('is', 'This is a string');
 charindex 
-----------
         3
(1 row)

select CHARINDEX('is', 'This is a string', 4);
 charindex 
-----------
         6
(1 row)

-- test STUFF function
select STUFF(n'abcdef', 2, 3, n'ijklmn');  
   stuff   
-----------
 aijklmnef
(1 row)

select STUFF(N' abcdef', 2, 3, N'ijklmn ');
    stuff    
-------------
  ijklmn def
(1 row)

select STUFF(N'abcdef', 2, 3, N' ijklmn ');
    stuff    
-------------
 a ijklmn ef
(1 row)

select STUFF(N'abcdef', 2, 3, N'ijklmn  ');
    stuff    
-------------
 aijklmn  ef
(1 row)

-- test corner cases
-- when start is negative or zero or longer than expr, return NULL
select STUFF(n'abcdef', -1, 3, n'ijklmn');  
 stuff 
-------
 
(1 row)

select STUFF(n'abcdef', 0, 3, n'ijklmn');  
 stuff 
-------
 
(1 row)

select STUFF(n'abcdef', 7, 3, n'ijklmn');  
 stuff 
-------
 
(1 row)

-- when length is negative, return NULL
select STUFF(n'abcdef', 2, -3, n'ijklmn');  
 stuff 
-------
 
(1 row)

-- when length is zero, just insert without deleting
select STUFF(n'abcdef', 2, 0, n'ijklmn');  
    stuff     
--------------
 aijklmnbcdef
(1 row)

-- when length is longer than expr, delete up to the last character in expr
select STUFF(n'abcdef', 2, 7, n'ijklmn');
  stuff  
---------
 aijklmn
(1 row)

-- when replace_expr is NULL, just delete without inserting
select STUFF(n'abcdef', 2, 3, NULL);
 stuff 
-------
 aef
(1 row)

-- when argument are type unknown
select STUFF('abcdef', 2, 3, 'ijklmn');
   stuff   
-----------
 aijklmnef
(1 row)

select STUFF('abcdef', 2, 3, n'ijklmn');
   stuff   
-----------
 aijklmnef
(1 row)

select STUFF(n'abcdef', 2, 3, 'ijklmn');
   stuff   
-----------
 aijklmnef
(1 row)

-- when argument are type text
SELECT STUFF(CAST('abcdef' as text), 2, 3, CAST('ijklmn' as text));
   stuff   
-----------
 aijklmnef
(1 row)

SELECT STUFF(CAST('abcdef' as text), 2, 3, 'ijklmn');
   stuff   
-----------
 aijklmnef
(1 row)

SELECT STUFF('abcdef', 2, 3, CAST('ijklmn' as text));
   stuff   
-----------
 aijklmnef
(1 row)

-- when argument are type sys.varchar
SELECT STUFF(CAST('abcdef' as sys.varchar), 2, 3, CAST('ijklmn' as sys.varchar));
   stuff   
-----------
 aijklmnef
(1 row)

SELECT STUFF('abcdef', 2, 3, CAST('ijklmn' as sys.varchar));
   stuff   
-----------
 aijklmnef
(1 row)

SELECT STUFF(CAST('abcdef' as sys.varchar), 2, 3, 'ijklmn');
   stuff   
-----------
 aijklmnef
(1 row)

-- test ROUND function
-- test rounding to the left of decimal point
select ROUND(748.58, -1);
 round 
-------
   750
(1 row)

select ROUND(748.58, -2);
 round 
-------
   700
(1 row)

select ROUND(748.58, -3);
ERROR:  value overflows for numeric format
select ROUND(748.58, -4);
 round 
-------
     0
(1 row)

select ROUND(-648.1234, -2);
 round 
-------
  -600
(1 row)

select ROUND(-648.1234, -3);
ERROR:  value overflows for numeric format
select ROUND(-1548.1234, -3);
 round 
-------
 -2000
(1 row)

select ROUND(-1548.1234, -4);
ERROR:  value overflows for numeric format
-- test NULL input
select ROUND(NULL, -3);
 round 
-------
      
(1 row)

select ROUND(748.58, NULL);
 round 
-------
      
(1 row)

-- test rounding
SELECT ROUND(123.9994, 3);
  round  
---------
 123.999
(1 row)

SELECT ROUND(123.9995, 3);
  round  
---------
 124.000
(1 row)

SELECT ROUND(123.4545, 2);
 round  
--------
 123.45
(1 row)

SELECT ROUND(123.45, -2);
 round 
-------
   100
(1 row)

-- test function parameter, i.e. truncation when not NULL or 0
SELECT ROUND(150.75, 0);
 round 
-------
   151
(1 row)

SELECT ROUND(150.75, 0, 0);
 round 
-------
   151
(1 row)

SELECT ROUND(150.75, 0, NULL);
 round 
-------
   151
(1 row)

SELECT ROUND(150.75, 0, 1);
 round 
-------
   150
(1 row)

-- test negative numbers
SELECT ROUND(-150.49, 0);
 round 
-------
  -150
(1 row)

SELECT ROUND(-150.75, 0);
 round 
-------
  -151
(1 row)

SELECT ROUND(-150.49, 0, 1);
 round 
-------
  -150
(1 row)

SELECT ROUND(-150.75, 0, 1);
 round 
-------
  -150
(1 row)

-- test SELECT ROUND(col, )
create table t1 (col numeric(4,2));
insert into t1 values (64.24);
insert into t1 values (79.65);
insert into t1 values (NULL);
select ROUND(col, 3) from t1;
 round  
--------
 64.240
 79.650
       
(3 rows)

select ROUND(col, 2) from t1;
 round 
-------
 64.24
 79.65
      
(3 rows)

select ROUND(col, 1) from t1;
 round 
-------
  64.2
  79.7
      
(3 rows)

select ROUND(col, 0) from t1;
 round 
-------
    64
    80
      
(3 rows)

select ROUND(col, -1) from t1;
 round 
-------
    60
    80
      
(3 rows)

select ROUND(col, -2) from t1;
ERROR:  value overflows for numeric format
select ROUND(col, -3) from t1;
 round 
-------
     0
     0
      
(3 rows)

select ROUND(col, 1, 1) from t1;
 round 
-------
  64.2
  79.6
      
(3 rows)

drop table t1;
-- test DAY function
select DAY(CAST('2016-12-26 23:30:05.523456+8' AS datetimeoffset));
 day 
-----
  26
(1 row)

select DAY(CAST('2016-12-26 23:30:05.523456' AS datetime2));
 day 
-----
  26
(1 row)

select DAY(CAST('2016-12-26 23:30:05' AS smalldatetime));
 day 
-----
  26
(1 row)

select DAY(CAST('04:12:34.876543' AS time));
 day 
-----
   1
(1 row)

select DAY(CAST('2037-03-01' AS date));
 day 
-----
   1
(1 row)

select DAY(CAST('2037-03-01 23:30:05.523' AS sys.datetime));
 day 
-----
   1
(1 row)

-- test MONTH function
select MONTH('2016-12-26 23:30:05.523456+8'::datetimeoffset);
 month 
-------
    12
(1 row)

select MONTH('2016-12-26 23:30:05.523456'::datetime2);
 month 
-------
    12
(1 row)

select MONTH('2016-12-26 23:30:05'::smalldatetime);
 month 
-------
    12
(1 row)

select MONTH('04:12:34.876543'::time);
 month 
-------
     1
(1 row)

select MONTH('2037-03-01'::date);
 month 
-------
     3
(1 row)

select MONTH('2037-03-01 23:30:05.523'::sys.datetime);
 month 
-------
     3
(1 row)

-- test YEAR function
select YEAR('2016-12-26 23:30:05.523456+8'::datetimeoffset);
 year 
------
 2016
(1 row)

select YEAR('2016-12-26 23:30:05.523456'::datetime2);
 year 
------
 2016
(1 row)

select YEAR('2016-12-26 23:30:05'::smalldatetime);
 year 
------
 2016
(1 row)

select YEAR('04:12:34.876543'::time);
 year 
------
 1900
(1 row)

select YEAR('2037-03-01'::date);
 year 
------
 2037
(1 row)

select YEAR('2037-03-01 23:30:05.523'::sys.datetime);
 year 
------
 2037
(1 row)

-- test SPACE function
select SPACE(NULL);
 space 
-------
 
(1 row)

select SPACE(2);
 space 
-------
   
(1 row)

select LEN(SPACE(5));
 len 
-----
   0
(1 row)

select DATALENGTH(SPACE(5));
 datalength 
------------
          5
(1 row)

-- test COUNT and COUNT_BIG aggregate function
CREATE TABLE t2(a int, b int);
INSERT INTO t2 VALUES(1, 100);
INSERT INTO t2 VALUES(2, 200);
INSERT INTO t2 VALUES(NULL, 300);
INSERT INTO t2 VALUES(2, 400);
CREATE TABLE t3(a varchar(255), b varchar(255),c int);
INSERT INTO t3 VALUES('xyz', 'a',1);
INSERT INTO t3 VALUES('xyz', 'b',1);
INSERT INTO t3 VALUES('abc', 'a',2);
INSERT INTO t3 VALUES('abc', 'b',2);
INSERT INTO t3 VALUES('efg', 'a',3);
INSERT INTO t3 VALUES('efg', 'b',3);
INSERT INTO t3 VALUES(NULL, NULL, 1);
-- Aggregation Function Syntax
-- COUNT[_BIG] ( { [ [ ALL | DISTINCT ] expression ] | * } )
-- should return all rows - 4
SELECT COUNT(*) from t2;
 count 
-------
     4
(1 row)

SELECT pg_typeof(COUNT(*)) from t2;
 pg_typeof 
-----------
 integer
(1 row)

SELECT COUNT_BIG(*) from t2;
 count_big 
-----------
         4
(1 row)

SELECT pg_typeof(COUNT_BIG(*)) from t2;
 pg_typeof 
-----------
 bigint
(1 row)

-- should return all rows where a is not NULL - 3
SELECT COUNT(a) from t2;
 count 
-------
     3
(1 row)

SELECT pg_typeof(COUNT(a)) from t2;
 pg_typeof 
-----------
 integer
(1 row)

SELECT COUNT_BIG(a) from t2;
 count_big 
-----------
         3
(1 row)

SELECT pg_typeof(COUNT_BIG(a)) from t2;
 pg_typeof 
-----------
 bigint
(1 row)

-- should return all rows where a is not NULL - 3
SELECT COUNT(ALL a) from t2;
 count 
-------
     3
(1 row)

SELECT pg_typeof(COUNT(ALL a)) from t2;
 pg_typeof 
-----------
 integer
(1 row)

SELECT COUNT_BIG(ALL a) from t2;
 count_big 
-----------
         3
(1 row)

SELECT pg_typeof(COUNT_BIG(ALL a)) from t2;
 pg_typeof 
-----------
 bigint
(1 row)

-- should return all rows where a is distinct - 2
SELECT COUNT(DISTINCT a) from t2;
 count 
-------
     2
(1 row)

SELECT pg_typeof(COUNT(DISTINCT a)) from t2;
 pg_typeof 
-----------
 integer
(1 row)

SELECT COUNT_BIG(DISTINCT a) from t2;
 count_big 
-----------
         2
(1 row)

SELECT pg_typeof(COUNT_BIG(DISTINCT a)) from t2;
 pg_typeof 
-----------
 bigint
(1 row)

-- Analytic Function Syntax
-- COUNT[_BIG] ( [ ALL ]  { expression | * } ) OVER ( [ <partition_by_clause> ] )
SELECT pg_typeof(COUNT(*) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 integer
 integer
 integer
 integer
(4 rows)

SELECT pg_typeof(COUNT_BIG(*) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 bigint
 bigint
 bigint
 bigint
(4 rows)

SELECT pg_typeof(COUNT(a) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 integer
 integer
 integer
 integer
(4 rows)

SELECT pg_typeof(COUNT_BIG(a) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 bigint
 bigint
 bigint
 bigint
(4 rows)

SELECT pg_typeof(COUNT(ALL a) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 integer
 integer
 integer
 integer
(4 rows)

SELECT pg_typeof(COUNT_BIG(ALL a) OVER (PARTITION BY a)) from t2;
 pg_typeof 
-----------
 bigint
 bigint
 bigint
 bigint
(4 rows)

SELECT COUNT(*) from t3;
 count 
-------
     7
(1 row)

SELECT a, b, COUNT(*) OVER () from t3;
  a  | b | count 
-----+---+-------
 xyz | a |     7
 xyz | b |     7
 abc | a |     7
 abc | b |     7
 efg | a |     7
 efg | b |     7
     |   |     7
(7 rows)

-- The result for order by is different in sql server because we have
-- an ordering issue for null type (JIRA: BABEL-788)
SELECT a, b, COUNT(*) OVER (ORDER BY a) from t3;
  a  | b | count 
-----+---+-------
 abc | b |     2
 abc | a |     2
 efg | a |     4
 efg | b |     4
 xyz | a |     6
 xyz | b |     6
     |   |     7
(7 rows)

SELECT a, b, COUNT(*) OVER (ORDER BY a DESC) from t3;
  a  | b | count 
-----+---+-------
     |   |     1
 xyz | b |     3
 xyz | a |     3
 efg | b |     5
 efg | a |     5
 abc | b |     7
 abc | a |     7
(7 rows)

SELECT a, b, COUNT(*) OVER(PARTITION BY a) from t3;
  a  | b | count 
-----+---+-------
 abc | b |     2
 abc | a |     2
 efg | a |     2
 efg | b |     2
 xyz | a |     2
 xyz | b |     2
     |   |     1
(7 rows)

SELECT a, b, COUNT(*) OVER(PARTITION BY a ORDER BY b) from t3;
  a  | b | count 
-----+---+-------
 abc | a |     1
 abc | b |     2
 efg | a |     1
 efg | b |     2
 xyz | a |     1
 xyz | b |     2
     |   |     1
(7 rows)

SELECT a, b, COUNT(*) OVER(PARTITION BY a ORDER BY b ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)  from t3;
  a  | b | count 
-----+---+-------
 abc | a |     2
 abc | b |     1
 efg | a |     2
 efg | b |     1
 xyz | a |     2
 xyz | b |     1
     |   |     1
(7 rows)

SELECT COUNT_BIG(*) from t3;
 count_big 
-----------
         7
(1 row)

SELECT a, b, COUNT_BIG(*) OVER () from t3;
  a  | b | count_big 
-----+---+-----------
 xyz | a |         7
 xyz | b |         7
 abc | a |         7
 abc | b |         7
 efg | a |         7
 efg | b |         7
     |   |         7
(7 rows)

SELECT a, b, COUNT_BIG(*) OVER (ORDER BY a) from t3;
  a  | b | count_big 
-----+---+-----------
 abc | b |         2
 abc | a |         2
 efg | a |         4
 efg | b |         4
 xyz | a |         6
 xyz | b |         6
     |   |         7
(7 rows)

SELECT a, b, COUNT_BIG(*) OVER (ORDER BY a DESC) from t3;
  a  | b | count_big 
-----+---+-----------
     |   |         1
 xyz | b |         3
 xyz | a |         3
 efg | b |         5
 efg | a |         5
 abc | b |         7
 abc | a |         7
(7 rows)

SELECT a, b, COUNT_BIG(*) OVER(PARTITION BY a) from t3;
  a  | b | count_big 
-----+---+-----------
 abc | b |         2
 abc | a |         2
 efg | a |         2
 efg | b |         2
 xyz | a |         2
 xyz | b |         2
     |   |         1
(7 rows)

SELECT a, b, COUNT_BIG(*) OVER(PARTITION BY a ORDER BY b) from t3;
  a  | b | count_big 
-----+---+-----------
 abc | a |         1
 abc | b |         2
 efg | a |         1
 efg | b |         2
 xyz | a |         1
 xyz | b |         2
     |   |         1
(7 rows)

SELECT a, b, COUNT_BIG(*) OVER(PARTITION BY a ORDER BY b ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)  from t3;
  a  | b | count_big 
-----+---+-----------
 abc | a |         2
 abc | b |         1
 efg | a |         2
 efg | b |         1
 xyz | a |         2
 xyz | b |         1
     |   |         1
(7 rows)

-- COUNT(*) takes no parameters and does not support the use of DISTINC, expect error
SELECT COUNT(DISTINCT *) from t3;
ERROR:  syntax error at or near "*"
LINE 1: SELECT COUNT(DISTINCT *) from t3;
                              ^
SELECT COUNT(ALL *) from t3;
ERROR:  syntax error at or near "*"
LINE 1: SELECT COUNT(ALL *) from t3;
                         ^
DROP TABLE t2;
DROP TABLE t3;
-- clean up
drop function test_func;
drop table employees;
drop table employee_audits;
drop function log_last_name_changes;
drop function test_increment;
drop function test_increment1;
drop table dateadd_table;
drop procedure dateadd_procedure;
-- test inline table-valued functions
-- simple case
create function itvf1 (@number int) returns table as return (select 1 as a, 2 as b);
select * from itvf1(5);
 a | b 
---+---
 1 | 2
(1 row)

-- should fail because column names are not specified
create function itvf2 (@number int) returns table as return (select 1, 2);
ERROR:  CREATE FUNCTION failed because a column name is not specified for column 1
-- select from a table
create table example_table(name text, age int);
insert into example_table values('hello', 3);
-- should have 'a' and 'b' as result column names
create function itvf3 (@number int) returns table as return (select name as a, age as b from example_table);
select * from itvf3(5);
   a   | b 
-------+---
 hello | 3
(1 row)

-- test returning multiple rows
insert into example_table values('hello1', 4);
insert into example_table values('hello2', 5);
insert into example_table values('hello3', 6);
select * from itvf3(5);
   a    | b 
--------+---
 hello  | 3
 hello1 | 4
 hello2 | 5
 hello3 | 6
(4 rows)

-- invoke a function
create function itvf4 (@number int) returns table as
return (select sys.serverproperty(N'collation') as property1, sys.serverproperty(N'IsSingleUser') as property2);
select * from itvf4(5);
          property1           | property2 
------------------------------+-----------
 sql_latin1_general_cp1_ci_as | 0
(1 row)

-- case where the return table has only one column - Postgres considers these as
-- scalar functions
create or replace function itvf5 (@number int) returns table as return (select 1 as a);
select * from itvf5(5);
 a 
---
 1
(1 row)

create or replace function itvf6 (@number int) returns table as
return (select sys.serverproperty(N'collation') as property);
select * from itvf6(5);
           property           
------------------------------
 sql_latin1_general_cp1_ci_as
(1 row)

-- complex queries with use of function parameter
create table id_name(id int, name text);
insert into id_name values(1001, 'adam');
insert into id_name values(1002, 'bob');
insert into id_name values(1003, 'chaz');
insert into id_name values(1004, 'dave');
insert into id_name values(1005, 'ed');
create table id_score(id int, score int);
insert into id_score values(1001, 90);
insert into id_score values(1001, 70);
insert into id_score values(1002, 90);
insert into id_score values(1002, 80);
insert into id_score values(1003, 80);
insert into id_score values(1003, 70);
insert into id_score values(1004, 80);
insert into id_score values(1004, 60);
insert into id_score values(1005, 80);
insert into id_score values(1005, 100);
create function itvf7 (@number int) returns table as return (
select n.id, n.name as first_name, sum(s.score) as total_score
from id_name as n
join id_score as s
on n.id = s.id
where s.id <= @number
group by n.id, n.name
order by n.id
);
select * from itvf7(1004);
  id  | first_name | total_score 
------+------------+-------------
 1001 | adam       |         160
 1002 | bob        |         170
 1003 | chaz       |         150
 1004 | dave       |         140
(4 rows)

-- test inline table-valued function with table-valued parameter
create type tableType as table(
	a text not null,
	b int primary key,
	c int);
create function itvf8 (@number int, @tableVar tableType READONLY) returns table as return (
select n.id, n.name as first_name, sum(s.score) as total_score
from id_name as n
join id_score as s
on n.id = s.id
where s.id <= @number and s.id in (select c from @tableVar)
group by n.id, n.name
order by n.id
);
create procedure itvf8_proc as
begin
	declare @tableVariable tableType
	insert into @tableVariable values('hello1', 1, 1001)
	insert into @tableVariable values('hello2', 2, 1002)
	select * from itvf8(1004, @tableVariable)
end;
call itvf8_proc();
  id  | first_name | total_score 
------+------------+-------------
 1001 | adam       |         160
 1002 | bob        |         170
(2 rows)

-- test using parameter in projection list
create function itvf9(@number int) returns table as return (
select @number as a from id_name
);
select * from itvf9(1);
 a 
---
 1
 1
 1
 1
 1
(5 rows)

-- test invalid ITVFs
-- function does not have RETURN QUERY
create function itvf10(@number int) returns table as BEGIN select * from id_name END;
ERROR:  syntax error near 'BEGIN' at line 1 and character position 0
CONTEXT:  compilation of PL/tsql function "itvf10" near line 1
-- function has more than one RETURN QUERY
create function itvf11(@number int) returns table as
BEGIN
	return select * from id_name
	return select id from id_name
END;
ERROR:  syntax error near 'BEGIN' at line 1 and character position 0
CONTEXT:  compilation of PL/tsql function "itvf11" near line 1
-- test creating ITVF in a transaction and rollback - should still work as
-- normal despite the function validator's modification of the pg_proc entry
begin transaction;
create function itvf12(@number int) returns table as return (
select @number as a from id_name
);
rollback;
select * from itvf12(1);
ERROR:  function itvf12(integer) does not exist
LINE 1: select * from itvf12(1);
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- "AS" keyword is optional in TSQL function
\tsql on
create function babel651_f() returns int
begin
  return 1
end
go
create table babel651_t(a int);
go
create function babel651_itvf() returns table
  return (select * from babel651_t)
go
create function babel651_mstvf(@i int) returns @tableVar table
(
	a text not null
)
begin
	insert into @tableVar values('hello1');
end;
go
select babel651_f();
go
 babel651_f 
------------
          1
(1 row)

select * from babel651_itvf();
go
 a 
---
(0 rows)

select * from babel651_mstvf(1);
go
   a    
--------
 hello1
(1 row)

\tsql off
-- clean up
drop function itvf1;
drop table example_table;
drop function itvf3;
drop function itvf4;
drop function itvf5;
drop function itvf6;
drop table id_name;
drop table id_score;
drop function itvf7;
drop procedure itvf8_proc;
drop function itvf8;
drop type tableType;
drop function itvf9;
drop table babel651_t;
drop function babel651_f;
drop function babel651_itvf;
drop function babel651_mstvf;
-- test RETURN not followed by a semicolon
\tsql on
create function test_return1(@stringToSplit VARCHAR(MAX))
RETURNS @returnList TABLE([Name] [nvarchar] (500))
AS
BEGIN
	RETURN
END
GO
select * from test_return1('test');
GO
 name 
------
(0 rows)

drop function test_return1;
GO
create function test_return2(@stringToSplit VARCHAR(MAX))
RETURNS @returnList TABLE([Name] [nvarchar] (500))
AS
BEGIN
	RETURN;
END
GO
select * from test_return2('test');
GO
 name 
------
(0 rows)

drop function test_return2;
GO
create function test_return3(@a int)
RETURNS @returnList TABLE([Name] [nvarchar] (500))
AS
BEGIN
	IF @a = 1
		RETURN
	SELECT @a = 2
	INSERT into @returnList values('abc')
	RETURN
END
GO
select * from test_return3(1);
GO
 name 
------
(0 rows)

select * from test_return3(2);
GO
 name 
------
 abc
(1 row)

drop function test_return3;
GO
create function test_return4(@a int)
RETURNS @returnList TABLE([Name] [nvarchar] (500))
AS
BEGIN
	IF @a = 1
		RETURN
	ELSE
		SELECT @a = 2
		INSERT into @returnList values('abc')
		RETURN
END
GO
select * from test_return4(1);
GO
 name 
------
(0 rows)

select * from test_return4(2);
GO
 name 
------
 abc
(1 row)

drop function test_return4;
GO
\tsql off
