#!/usr/bin/env bash

set -e

# Attempt to clone the engine repository based on where the workflow is being run from.
# First, see if the user who triggered the workflow has a fork of the engine
# repo that also contains a branch with the same name as the branch that
# triggered the workflow. If not, see if there's a branch in the project engine
# repo that has the same name. If neither of those is true, just use the
# default branch in the project engine repo.

# TODO: create unit tests for this script

# WARNING! Use "GH" instead of "GITHUB" for variable names to avoid possible
# conflict with github workflow environment variables.

# Look for a config file and read it if it's there. Intentionally use -x
# instead of -r so we get an error if we can't read the config file.
CONFIG_FILE=${0}.conf
if [ -r "$CONFIG_FILE" ]; then
    echo "Sourcing config file $CONFIG_FILE"
    . $CONFIG_FILE
else
    if [ -e "$CONFIG_FILE" ]; then
        # Unlike the case below, if the file exists but isn't readable that is
        # almost certainly not what the user is expecting, so treat it as an error.
        echo "ERROR: config file $CONFIG_FILE is not readable"
        exit 1
    else
        echo "WARNING: config file $CONNFIG_FILE not found; using defaults."
    fi
fi

if [ "$1" == -n ]; then
    DRY_RUN=1
    echo
    echo DRY RUN MODE
    echo

    shift
fi
ACTIONS_STEP_DEBUG=1
if [ -n "$ACTIONS_STEP_DEBUG" -o -n "$DRY_RUN" ]; then
    echo
    echo "ACTIONS_STEP_DEBUG='$ACTIONS_STEP_DEBUG'"
    echo environment:
    env
    echo
    echo $GITHUB_EVENT_PATH
    echo
    cat $GITHUB_EVENT_PATH
    echo 
    echo
fi

# Spit out some debug info. NOTE! this will differentiate between a *blank*
# variable and a non-existant one, so don't replace this with `echo`!
env | egrep '^GH_*|GITHUB_REPOSITORY_OWNER|GITHUB_EVENT_NAME|GITHUB_HEAD_REF|GITHUB_REF|GITHUB_REF_NAME' | sort

# Per [1], referenced from [2], as of 2022-05-23 Github actions work
# differently when run in pull requests vs branches. In a PR, GITHUB_HEAD_REF
# contains the original branch name while GITHUB_REF and GITHUB_REF_NAME refer
# to something generated for the PR (see [3] and [4], which were created by
# hacking this script to run `env`). For a branch, GITHUB_HEAD_REF is blank and
# GITHUB_REF_NAME is the name of the branch (see [5] and [6]).
#
# 1: https://github.com/ScribeMD/slack-templates/blob/f98a8930d8a36f65adbd581518b79fca78557f4b/src/slack_notification.py#L125-L139
# 2: https://github.com/github/docs/issues/15319
# 3: https://github.com/babelfish-for-postgresql/babelfish_extensions/runs/6562890249?check_suite_focus=true#step:4:43
# 4: https://github.com/babelfish-for-postgresql/babelfish_extensions/runs/6562890249?check_suite_focus=true#step:4:107
# 5: https://github.com/nasbyj/babelfish_extensions/runs/6562881485?check_suite_focus=true#step:4:105
# 6: https://github.com/nasbyj/babelfish_extensions/runs/6562881485?check_suite_focus=true#step:4:83
BRANCH=$GITHUB_HEAD_REF
[ -n "$BRANCH" ] || BRANCH=$GITHUB_REF_NAME

# Likewise, getting the repo name is also tricky. There are two places buried
# in event.json (found at $GITHUB_EVENT_PATH) to look, depending on if the
# event is a pull request or not. The easiest way to dig into those is for our
# action to set some environment variables (see
# ../composite-actions/build-modified-postgres/action.yml). Here we simply see
# if the PR one is empty and punt to the non-PR version if so.
REPO_FULL_NAME=$GH_PR_HEAD_REPO_FULL_NAME
[ -n "$REPO_FULL_NAME" ] || REPO_NAME=$GH_REPOSITORY_FULL_NAME

# See if user has an engine repository with the same name and branch.
# See https://unix.stackexchange.com/questions/474805/verify-if-a-url-exists
check_repo () {
    echo "Checking $1"
    wget --spider "$1" || return $?
}

BASE_URL=https://github.com/$REPO_NAME/postgresql_modified_for_babelfish # NO '/'
BRANCH_OPTION="--branch $BRANCH"
if check_repo "${BASE_URL}/tree/$BRANCH"; then
    echo "Found matching branch $BRANCH at $BASE_URL, using that instead of public repo"
else
    # TODO: add support for checking tags in private repo

    # Maybe there's a matching branch in the public repo
    BASE_URL=
    BASE_URL=https://github.com/babelfish-for-postgresql/postgresql_modified_for_babelfish # NO '/'

    if check_repo "${BASE_URL}/tree/$BRANCH"; then
        echo "Using $BRANCH from project engine repo"
    else
        # TODO: add support for checking tags

        # General default case. This is mainly meant to support back-porting.
        # IE, BABEL_1_1_STABLE needs to download BABEL_1_1_STABLE__PG_13_5.
        # Instead of hard-coding that into the script and messing with the
        # script in every version, we pull it from the config file.
        #
        # Note that DEFAULT_BRANCH may (or may not) be set in clone_engine_repo.conf
        echo "Did not find matching engine branch; using project default $DEFAULT_BRANCH"
        if [ -n "$DEFAULT_BRANCH" ]; then
            # It doesn't seem worth testing to see if the branch exists.
            # Presumably people are configuring it correctly.
            BRANCH_OPTION="--branch $DEFAULT_BRANCH"
        else
            BRANCH_OPTION=''
        fi
    fi
fi
GIT_URL=${BASE_URL}.git

if [ -n "$DRY_RUN" ]; then
    echo DRY RUN: NOT EXECUTING \'git clone "$BRANCH_OPTION" "$GIT_URL"\'
    exit 1
fi

echo running git clone "$BRANCH_OPTION" "$GIT_URL"
git clone $BRANCH_OPTION "$GIT_URL" && exit
rc=$?
echo "git clone failed with return code $rc"
exit $rc
