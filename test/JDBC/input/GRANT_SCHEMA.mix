-- tsql
-- create objects
create database babel_4344_d1;
go

use babel_4344_d1;
go

create login babel_4344_l1 with password = '12345678'
go

create user babel_4344_u1 for login babel_4344_l1;
go

create login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz with password = '12345678'
go

create user abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz for login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

create login αιώνια with password = '12345678'
go

create user αιώνια for login αιώνια;
go

create login ログイン with password = '12345678'
go

create user ログイン for login ログイン;
go

create schema babel_4344_s1;
go

create schema "BAbel_4344 S1";
go

create table "babel_4344 s1"."babel_4344 t1"(a int);
go

create schema αγάπη;
go

create schema スキーマ;
go

create schema babel_4344_s2 authorization babel_4344_u1;
go

create table babel_4344_t1(a int);
go

create table babel_4344_s1.babel_4344_t1(a int);
go

create table babel_4344_s2.babel_4344_t1(a int);
go

create table αγάπη.abc(a int);
go

create table スキーマ.abc(a int);
go

create table babel_4344_t3(a int, b int);
go

create table babel_4344_s1.babel_4344_t3(a int, b int);
go

create schema "update pg_class set oid = 0 where relname = 'babel_4344_t1'";
go

create view babel_4344_v1 as select 1;
go

create view babel_4344_s1.babel_4344_v1 as select 2;
go

create proc babel_4344_p1 as select 1;
go

create proc babel_4344_s1.babel_4344_p1 as select 2;
go

create proc babel_4344_s1.babel_4344_p3 as select 3;
go

CREATE FUNCTION babel_4344_f1() returns int begin declare @a int; set @a = 1; return @a; end 
go

CREATE FUNCTION babel_4344_s1.babel_4344_f1() returns int begin declare @a int; set @a = 1; return @a; END
go

-- tests with greek character (one byte) and japanese character (muti bytes)
grant SELECT on schema::babel_4344_S1 to public, αιώνια, ログイン;
go

grant select on schema::αγάπη to αιώνια, ログイン;
go

grant select on schema::スキーマ to ログイン, αιώνια;
go

-- test special database roles
grant SELECT on schema::babel_4344_S1 to db_owner; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to sys; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to information_schema; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to dbo; -- throws an error
go

-- tsql user=ログイン password=12345678 
use babel_4344_d1;
go

select * from αγάπη.abc;
go

select * from スキーマ.abc;
go

select * from babel_4344_S1.babel_4344_t1;
go

use master;
go

-- tsql user=αιώνια password=12345678 
use babel_4344_d1;
go

select * from αγάπη.abc;
go

select * from スキーマ.abc;
go

select * from babel_4344_S1.babel_4344_t1;
go

use master;
go

-- tsql user=babel_4344_l1 password=12345678 
use babel_4344_d1;
go

-- User has select privileges, tables and views be accessible
select * from babel_4344_s1.babel_4344_t1
go
select * from babel_4344_s1.babel_4344_v1;
go
use master;
go

-- tsql
-- object names having more than 64 bytes
create schema abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

create table abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz(a int);
go

grant select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

-- check for inconsistent metadata
select COUNT(*) FROM sys.babelfish_inconsistent_metadata();
go

revoke select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

drop user abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

drop login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

-- unsupported features
grant select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1 with grant option;
go

revoke select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1 cascade;
go

revoke grant option for select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1;
go

grant select on abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1;
go

revoke select on abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz from babel_4344_u1;
go

drop table abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

drop schema abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

use babel_4344_d1;
go
revoke select on schema::babel_4344_s1 from public, αιώνια, ログイン;
go

-- tsql user=babel_4344_l1 password=12345678 
use babel_4344_d1;
go

-- User doesn't have any privileges, objects should not be accessible
select * from babel_4344_t1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(1);
go
select * from babel_4344_v1;
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_f1();
go
select * from babel_4344_s1.babel_4344_f1();
go
use master;
go

-- tsql
-- GRANT OBJECT privilege
use babel_4344_d1;
go
grant SELECT on schema::"bAbel_4344 s1" to BABEL_4344_U1;
go
grant SELECT on schema::"update pg_class set oid = 0 where relname = 'babel_4344_t1'" to BABEL_4344_U1;
go
grant SELECT on "babel_4344_t1" to BABEL_4344_U1;
go
grant SELECT on "babel_4344_s1".babel_4344_t1 to babel_4344_u1;
go
grant all on babel_4344_s1.babel_4344_t1 to "babel_4344_u1";
go
grant select on babel_4344_t3(a) to babel_4344_u1; -- column privilege
go
grant select on babel_4344_s1.babel_4344_t3(a) to babel_4344_u1; -- column privilege
go
grant select on babel_4344_v1 to babel_4344_u1;
go
grant select on babel_4344_s1.babel_4344_v1 to babel_4344_u1;
go
grant execute on babel_4344_p1 to babel_4344_u1;
go
grant execute on babel_4344_s1.babel_4344_p1 to babel_4344_u1;
go
-- inside a transaction, permission will not be granted since it is rolled back
begin transaction;
exec sp_executesql N'grant execute on babel_4344_s1.babel_4344_p3 to babel_4344_u1;';
rollback transaction;
go

-- Mixed case
grant Execute on Babel_4344_F1 to Babel_4344_u1;
go
grant execute on BABEL_4344_s1.babel_4344_f1 to babEL_4344_u1;
go
-- Grant schema permission to its owner, should fail
grant select on schema::babel_4344_s2 to babel_4344_u1; -- should fail
go
grant select on schema::babel_4344_s2 to jdbc_user; -- should fail
go
grant SELECT on schema::"babel_4344_s2" to guest; -- should pass 
go
grant select on schema::"" to guest; -- should fail 
go
grant select on schema::non_existing_schema to guest; -- should fail 
go
-- grant statement via a procedure
create procedure grant_perm_proc as begin exec('grant select on schema::[] to guest') end;
go
exec grant_perm_proc; -- should fail, invalid GRANT statement
go
-- non-existing role
grant SELECT on schema::dbo to guest, babel_4344_u3; -- should fail
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_t1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(2);
go
select * from babel_4344_t3; -- not accessible, only column privilege is granted
go
select * from babel_4344_s1.babel_4344_t3 -- not accessible, only column privilege is granted
go
select * from babel_4344_v1;
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p3; -- should fail, grant statement was rolled back
go
select * from BABEl_4344_f1();
go
select * from babEL_4344_s1.babel_4344_f1();
go
-- Grant schema permission to its owner
grant select on schema::babel_4344_s2 to babel_4344_u1; -- should fail
go
grant select on schema::babel_4344_s2 to guest; -- should pass 
go
grant select on schema::babel_4344_s1 to babel_4344_u1; -- should fail
go
use master;
go

-- tsql
-- GRANT SCHEMA privilege
use babel_4344_d1;
go
grant control on schema::babel_4344_s1 to babel_4344_u1; -- should fail, 'control' is not supported
go
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
use master;
go

-- psql
-- GRANT statement add an entry to the catalog
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions
where schema_name = 'babel_4344_s1' collate "C" order by permission; -- and object_name = 'ALL' collate "C"
go

-- tsql
-- GRANT SCHEMA privilege again
use babel_4344_d1;
go
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
-- GRANT OBJECT privilege again
grant select on babel_4344_s1.babel_4344_v1 to babel_4344_u1;
go
use master;
go

-- psql
-- check the consistency of catalog
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions
where schema_name = 'babel_4344_s1' collate "C" order by permission;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT and SCHEMA privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(3);
go
select * from babel_4344_s1.babel_4344_t3
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_s1.babel_4344_f1();
go
use master;
go

-- tsql
-- REVOKE SCHEMA privilege
use babel_4344_d1;
go
revoke select, insert, execute on schema::babel_4344_s1 from babel_4344_u1;
go
use master;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(3); 
go
select * from babel_4344_s1.babel_4344_t3 -- not accessible
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_s1.babel_4344_f1();
go
select * from babel_4344_s2.babel_4344_t1;
go
use master;
go

-- tsql
-- create new objects in same schema
use babel_4344_d1;
go
-- Grant the permissions again
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
grant select, insert, execute on schema::information_schema to babel_4344_u1;
go
create table babel_4344_s1.babel_4344_t2(a int);
go
create view babel_4344_s1.babel_4344_v2 as select 2;
go
create proc babel_4344_s1.babel_4344_p2 as select 2;
go
CREATE FUNCTION babel_4344_s1.babel_4344_f2() RETURNS INT AS BEGIN RETURN (SELECT COUNT(*) FROM sys.objects) END
go
use master;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has SCHEMA privileges,objects should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t2
go
insert into babel_4344_s1.babel_4344_t1 values(4);
go
select * from babel_4344_s1.babel_4344_v2;
go
exec babel_4344_s1.babel_4344_p2;
go
select * from babel_4344_s1.babel_4344_f2();
go
select * from "bAbel_4344 s1"."bAbel_4344 t1";
go
use master;
go

-- tsql
-- REVOKE OBJECT privileges
use babel_4344_d1;
go

REVOKE SELECT on schema::"bAbel_4344 s1" from "BABEL_4344_U1";
go
REVOKE SELECT on schema::"update pg_class set oid = 0 where relname = 'babel_4344_t1'" from BABEL_4344_U1;
go
GRANT SELECT on babel_4344_t1 to BABEL_4344_U1;
go

-- psql
-- should show original object names
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default order by object_name;
go

-- tsql
-- rename the objects where permissions are already granted
sp_rename 'babel_4344_t1', 'babel_4344_t1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_t1', 'babel_4344_t1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_t3', 'babel_4344_t3_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_v1', 'babel_4344_v1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_p1', 'babel_4344_p1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_f1', 'babel_4344_f1_new', 'OBJECT';
go

-- psql
-- should show renamed objects
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default order by object_name;
go

-- tsql
-- permissions are transferred to the new objects 
-- Revoke permissions from the new objects
REVOKE all on babel_4344_s1.babel_4344_t1_new FROM babel_4344_u1;
go
REVOKE select on babel_4344_s1.babel_4344_t3_new(a) FROM babel_4344_u1;
go
REVOKE select on babel_4344_s1.babel_4344_v1_new FROM babel_4344_u1;
go
REVOKE execute on babel_4344_s1.babel_4344_p1_new FROM babel_4344_u1;
go
REVOKE execute on babel_4344_s1.babel_4344_f1_new FROM babel_4344_u1;
go
REVOKE all on babel_4344_s1.babel_4344_f1_new FROM babel_4344_u1;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has SCHEMA privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_t1_new;
go
select * from babel_4344_s1.babel_4344_t1_new
go
insert into babel_4344_s1.babel_4344_t1_new values(5);
go
select * from babel_4344_s1.babel_4344_t3_new;
go
select * from babel_4344_s1.babel_4344_v1_new;
go
exec babel_4344_s1.babel_4344_p1_new;
go
select * from babel_4344_s1.babel_4344_f1_new();
go
select * from babel_4344_s2.babel_4344_t1;
go
use master;
go

-- tsql
-- REVOKE SCHEMA privileges
use babel_4344_d1;
go
revoke select, insert, execute on schema::babel_4344_s1 from babel_4344_u1;
go
use master;
go

-- psql
-- REVOKE on schema removes the entry from the catalog
select * from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has no privileges, shouldn't be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new;
go
insert into babel_4344_s1.babel_4344_t1_new values(5);
go
select * from babel_4344_s1.babel_4344_t3_new;
go
select * from babel_4344_s1.babel_4344_v1_new;
go
exec babel_4344_s1.babel_4344_p1_new;
go
select * from babel_4344_s1.babel_4344_f1_new();
go
use master;
go

-- psql
-- grant object permission
grant select on babel_4344_s1.babel_4344_t1_new to babel_4344_d1_babel_4344_u1;
go

-- tsql
-- grant schema permission
use babel_4344_d1;
go
grant select on schema::babel_4344_s1 to babel_4344_u1;
go
use master
go

-- tsql user=babel_4344_l1 password=12345678
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new; -- accessible
go
use master
go

-- psql
-- revoke schema permission
revoke select on all tables in schema babel_4344_s1 from babel_4344_d1_babel_4344_u1;
go

-- tsql user=babel_4344_l1 password=12345678
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new; -- not accessible
go
use master
go

-- tsql
-- Drop objects
use babel_4344_d1;
go

drop schema "update pg_class set oid = 0 where relname = 'babel_4344_t1'";
go

drop table babel_4344_t1_new;
go

drop table babel_4344_s1.babel_4344_t1_new;
go

drop table babel_4344_t3;
go

drop table babel_4344_s1.babel_4344_t3_new;
go

drop table babel_4344_s1.babel_4344_t2;
go

drop view babel_4344_v1;
go

drop view babel_4344_s1.babel_4344_v1_new;
go

drop view babel_4344_s1.babel_4344_v2;
go

drop proc babel_4344_p1;
go

drop proc babel_4344_s1.babel_4344_p1_new;
go

drop proc babel_4344_s1.babel_4344_p2;
go

drop proc babel_4344_s1.babel_4344_p3;
go

drop function babel_4344_f1;
go

drop function babel_4344_s1.babel_4344_f1_new;
go

drop function babel_4344_s1.babel_4344_f2;
go

drop schema babel_4344_s1;
go

drop table babel_4344_s2.babel_4344_t1;
go

drop schema babel_4344_s2;
go

drop table αγάπη.abc;
go

drop schema αγάπη;
go

drop table スキーマ.abc;
go

drop schema スキーマ;
go

drop table "babel_4344 s1"."babel_4344 t1";
go

drop schema "BAbel_4344 s1";
go

drop user babel_4344_u1;
go

drop user αιώνια;
go

drop user ログイン;
go

use master;
go

drop database babel_4344_d1;
go

-- tsql
-- Using Collation BBF_Unicode_CP1_CI_AI
-- create objects
create database babel_4344_d1 collate BBF_Unicode_CP1_CI_AI;
go

use babel_4344_d1;
go

create login babel_4344_l1 with password = '12345678'
go

create user babel_4344_u1 for login babel_4344_l1;
go

create login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz with password = '12345678'
go

create user abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz for login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

create login αιώνια with password = '12345678'
go

create user αιώνια for login αιώνια;
go

create login ログイン with password = '12345678'
go

create user ログイン for login ログイン;
go

create schema babel_4344_s1;
go

create schema "BAbel_4344 S1";
go

create table "babel_4344 s1"."babel_4344 t1"(a int);
go

create schema αγάπη;
go

create schema スキーマ;
go

create schema babel_4344_s2 authorization babel_4344_u1;
go

create table babel_4344_t1(a int);
go

create table babel_4344_s1.babel_4344_t1(a int);
go

create table babel_4344_s2.babel_4344_t1(a int);
go

create table αγάπη.abc(a int);
go

create table スキーマ.abc(a int);
go

create table babel_4344_t3(a int, b int);
go

create table babel_4344_s1.babel_4344_t3(a int, b int);
go

create schema "update pg_class set oid = 0 where relname = 'babel_4344_t1'";
go

create view babel_4344_v1 as select 1;
go

create view babel_4344_s1.babel_4344_v1 as select 2;
go

create proc babel_4344_p1 as select 1;
go

create proc babel_4344_s1.babel_4344_p1 as select 2;
go

create proc babel_4344_s1.babel_4344_p3 as select 3;
go

CREATE FUNCTION babel_4344_f1() returns int begin declare @a int; set @a = 1; return @a; end 
go

CREATE FUNCTION babel_4344_s1.babel_4344_f1() returns int begin declare @a int; set @a = 1; return @a; END
go

-- tests with greek character (one byte) and japanese character (muti bytes)
grant SELECT on schema::babel_4344_S1 to public, αιώνια, ログイン;
go

grant select on schema::αγάπη to αιώνια, ログイン;
go

grant select on schema::スキーマ to ログイン, αιώνια;
go

-- test special database roles
grant SELECT on schema::babel_4344_S1 to db_owner; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to sys; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to information_schema; -- throws an error
go

grant SELECT on schema::babel_4344_S1 to dbo; -- throws an error
go

-- tsql user=ログイン password=12345678 
use babel_4344_d1;
go

select * from αγάπη.abc;
go

select * from スキーマ.abc;
go

select * from babel_4344_S1.babel_4344_t1;
go

use master;
go

-- tsql user=αιώνια password=12345678 
use babel_4344_d1;
go

select * from αγάπη.abc;
go

select * from スキーマ.abc;
go

select * from babel_4344_S1.babel_4344_t1;
go

use master;
go

-- tsql user=babel_4344_l1 password=12345678 
use babel_4344_d1;
go

-- User has select privileges, tables and views be accessible
select * from babel_4344_s1.babel_4344_t1
go
select * from babel_4344_s1.babel_4344_v1;
go
use master;
go

-- tsql
-- object names having more than 64 bytes
create schema abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

create table abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz(a int);
go

grant select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

-- check for inconsistent metadata
select COUNT(*) FROM sys.babelfish_inconsistent_metadata();
go

revoke select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

drop user abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

drop login abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz;
go

-- unsupported features
grant select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1 with grant option;
go

revoke select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1 cascade;
go

revoke grant option for select on schema::abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1;
go

grant select on abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz to babel_4344_u1;
go

revoke select on abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz from babel_4344_u1;
go

drop table abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

drop schema abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwzyzabcdefghijklmnopqrstuvwzyz
go

use babel_4344_d1;
go
revoke select on schema::babel_4344_s1 from public, αιώνια, ログイン;
go

-- tsql user=babel_4344_l1 password=12345678 
use babel_4344_d1;
go

-- User doesn't have any privileges, objects should not be accessible
select * from babel_4344_t1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(1);
go
select * from babel_4344_v1;
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_f1();
go
select * from babel_4344_s1.babel_4344_f1();
go
use master;
go

-- tsql
-- GRANT OBJECT privilege
use babel_4344_d1;
go
grant SELECT on schema::"bAbel_4344 s1" to BABEL_4344_U1;
go
grant SELECT on schema::"update pg_class set oid = 0 where relname = 'babel_4344_t1'" to BABEL_4344_U1;
go
grant SELECT on "babel_4344_t1" to BABEL_4344_U1;
go
grant SELECT on "babel_4344_s1".babel_4344_t1 to babel_4344_u1;
go
grant all on babel_4344_s1.babel_4344_t1 to "babel_4344_u1";
go
grant select on babel_4344_t3(a) to babel_4344_u1; -- column privilege
go
grant select on babel_4344_s1.babel_4344_t3(a) to babel_4344_u1; -- column privilege
go
grant select on babel_4344_v1 to babel_4344_u1;
go
grant select on babel_4344_s1.babel_4344_v1 to babel_4344_u1;
go
grant execute on babel_4344_p1 to babel_4344_u1;
go
grant execute on babel_4344_s1.babel_4344_p1 to babel_4344_u1;
go
-- inside a transaction, permission will not be granted since it is rolled back
begin transaction;
exec sp_executesql N'grant execute on babel_4344_s1.babel_4344_p3 to babel_4344_u1;';
rollback transaction;
go

-- Mixed case
grant Execute on Babel_4344_F1 to Babel_4344_u1;
go
grant execute on BABEL_4344_s1.babel_4344_f1 to babEL_4344_u1;
go
-- Grant schema permission to its owner, should fail
grant select on schema::babel_4344_s2 to babel_4344_u1; -- should fail
go
grant select on schema::babel_4344_s2 to jdbc_user; -- should fail
go
grant SELECT on schema::"babel_4344_s2" to guest; -- should pass 
go
grant select on schema::"" to guest; -- should fail 
go
grant select on schema::non_existing_schema to guest; -- should fail 
go
-- grant statement via a procedure
create procedure grant_perm_proc as begin exec('grant select on schema::[] to guest') end;
go
exec grant_perm_proc; -- should fail, invalid GRANT statement
go
-- non-existing role
grant SELECT on schema::dbo to guest, babel_4344_u3; -- should fail
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_t1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(2);
go
select * from babel_4344_t3; -- not accessible, only column privilege is granted
go
select * from babel_4344_s1.babel_4344_t3 -- not accessible, only column privilege is granted
go
select * from babel_4344_v1;
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p1;
go
exec babel_4344_s1.babel_4344_p3; -- should fail, grant statement was rolled back
go
select * from BABEl_4344_f1();
go
select * from babEL_4344_s1.babel_4344_f1();
go
-- Grant schema permission to its owner
grant select on schema::babel_4344_s2 to babel_4344_u1; -- should fail
go
grant select on schema::babel_4344_s2 to guest; -- should pass 
go
grant select on schema::babel_4344_s1 to babel_4344_u1; -- should fail
go
use master;
go

-- tsql
-- GRANT SCHEMA privilege
use babel_4344_d1;
go
grant control on schema::babel_4344_s1 to babel_4344_u1; -- should fail, 'control' is not supported
go
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
use master;
go

-- psql
-- GRANT statement add an entry to the catalog
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions
where schema_name = 'babel_4344_s1' collate "C" order by permission; -- and object_name = 'ALL' collate "C"
go

-- tsql
-- GRANT SCHEMA privilege again
use babel_4344_d1;
go
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
-- GRANT OBJECT privilege again
grant select on babel_4344_s1.babel_4344_v1 to babel_4344_u1;
go
use master;
go

-- psql
-- check the consistency of catalog
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions
where schema_name = 'babel_4344_s1' collate "C" order by permission;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT and SCHEMA privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(3);
go
select * from babel_4344_s1.babel_4344_t3
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_s1.babel_4344_f1();
go
use master;
go

-- tsql
-- REVOKE SCHEMA privilege
use babel_4344_d1;
go
revoke select, insert, execute on schema::babel_4344_s1 from babel_4344_u1;
go
use master;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has OBJECT privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1
go
insert into babel_4344_s1.babel_4344_t1 values(3); 
go
select * from babel_4344_s1.babel_4344_t3 -- not accessible
go
select * from babel_4344_s1.babel_4344_v1;
go
exec babel_4344_s1.babel_4344_p1;
go
select * from babel_4344_s1.babel_4344_f1();
go
select * from babel_4344_s2.babel_4344_t1;
go
use master;
go

-- tsql
-- create new objects in same schema
use babel_4344_d1;
go
-- Grant the permissions again
grant select, insert, execute on schema::babel_4344_s1 to babel_4344_u1;
go
grant select, insert, execute on schema::information_schema to babel_4344_u1;
go
create table babel_4344_s1.babel_4344_t2(a int);
go
create view babel_4344_s1.babel_4344_v2 as select 2;
go
create proc babel_4344_s1.babel_4344_p2 as select 2;
go
CREATE FUNCTION babel_4344_s1.babel_4344_f2() RETURNS INT AS BEGIN RETURN (SELECT COUNT(*) FROM sys.objects) END
go
use master;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has SCHEMA privileges,objects should be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t2
go
insert into babel_4344_s1.babel_4344_t1 values(4);
go
select * from babel_4344_s1.babel_4344_v2;
go
exec babel_4344_s1.babel_4344_p2;
go
select * from babel_4344_s1.babel_4344_f2();
go
select * from "bAbel_4344 s1"."bAbel_4344 t1";
go
use master;
go

-- tsql
-- REVOKE OBJECT privileges
use babel_4344_d1;
go

REVOKE SELECT on schema::"bAbel_4344 s1" from "BABEL_4344_U1";
go
REVOKE SELECT on schema::"update pg_class set oid = 0 where relname = 'babel_4344_t1'" from BABEL_4344_U1;
go
GRANT SELECT on babel_4344_t1 to BABEL_4344_U1;
go

-- psql
-- should show original object names
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default order by object_name;
go

-- tsql
-- rename the objects where permissions are already granted
sp_rename 'babel_4344_t1', 'babel_4344_t1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_t1', 'babel_4344_t1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_t3', 'babel_4344_t3_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_v1', 'babel_4344_v1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_p1', 'babel_4344_p1_new', 'OBJECT';
go
sp_rename 'babel_4344_s1.babel_4344_f1', 'babel_4344_f1_new', 'OBJECT';
go

-- psql
-- should show renamed objects
select schema_name, object_name, permission, grantee, grantor from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default order by object_name;
go

-- tsql
-- permissions are transferred to the new objects 
-- Revoke permissions from the new objects
REVOKE all on babel_4344_s1.babel_4344_t1_new FROM babel_4344_u1;
go
REVOKE select on babel_4344_s1.babel_4344_t3_new(a) FROM babel_4344_u1;
go
REVOKE select on babel_4344_s1.babel_4344_v1_new FROM babel_4344_u1;
go
REVOKE execute on babel_4344_s1.babel_4344_p1_new FROM babel_4344_u1;
go
REVOKE execute on babel_4344_s1.babel_4344_f1_new FROM babel_4344_u1;
go
REVOKE all on babel_4344_s1.babel_4344_f1_new FROM babel_4344_u1;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has SCHEMA privileges, should be accessible.
use babel_4344_d1;
go
select * from babel_4344_t1_new;
go
select * from babel_4344_s1.babel_4344_t1_new
go
insert into babel_4344_s1.babel_4344_t1_new values(5);
go
select * from babel_4344_s1.babel_4344_t3_new;
go
select * from babel_4344_s1.babel_4344_v1_new;
go
exec babel_4344_s1.babel_4344_p1_new;
go
select * from babel_4344_s1.babel_4344_f1_new();
go
select * from babel_4344_s2.babel_4344_t1;
go
use master;
go

-- tsql
-- REVOKE SCHEMA privileges
use babel_4344_d1;
go
revoke select, insert, execute on schema::babel_4344_s1 from babel_4344_u1;
go
use master;
go

-- psql
-- REVOKE on schema removes the entry from the catalog
select * from sys.babelfish_schema_permissions where schema_name = 'babel_4344_s1' collate sys.database_default;
go

-- tsql user=babel_4344_l1 password=12345678
-- User has no privileges, shouldn't be accessible.
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new;
go
insert into babel_4344_s1.babel_4344_t1_new values(5);
go
select * from babel_4344_s1.babel_4344_t3_new;
go
select * from babel_4344_s1.babel_4344_v1_new;
go
exec babel_4344_s1.babel_4344_p1_new;
go
select * from babel_4344_s1.babel_4344_f1_new();
go
use master;
go

-- psql
-- grant object permission
grant select on babel_4344_s1.babel_4344_t1_new to babel_4344_d1_babel_4344_u1;
go

-- tsql
-- grant schema permission
use babel_4344_d1;
go
grant select on schema::babel_4344_s1 to babel_4344_u1;
go
use master
go

-- tsql user=babel_4344_l1 password=12345678
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new; -- accessible
go
use master
go

-- psql
-- revoke schema permission
revoke select on all tables in schema babel_4344_s1 from babel_4344_d1_babel_4344_u1;
go

-- tsql user=babel_4344_l1 password=12345678
use babel_4344_d1;
go
select * from babel_4344_s1.babel_4344_t1_new; -- not accessible
go
use master
go

-- tsql
-- Drop objects
use babel_4344_d1;
go

drop schema "update pg_class set oid = 0 where relname = 'babel_4344_t1'";
go

drop table babel_4344_t1_new;
go

drop table babel_4344_s1.babel_4344_t1_new;
go

drop table babel_4344_t3;
go

drop table babel_4344_s1.babel_4344_t3_new;
go

drop table babel_4344_s1.babel_4344_t2;
go

drop view babel_4344_v1;
go

drop view babel_4344_s1.babel_4344_v1_new;
go

drop view babel_4344_s1.babel_4344_v2;
go

drop proc babel_4344_p1;
go

drop proc babel_4344_s1.babel_4344_p1_new;
go

drop proc babel_4344_s1.babel_4344_p2;
go

drop proc babel_4344_s1.babel_4344_p3;
go

drop function babel_4344_f1;
go

drop function babel_4344_s1.babel_4344_f1_new;
go

drop function babel_4344_s1.babel_4344_f2;
go

drop schema babel_4344_s1;
go

drop table babel_4344_s2.babel_4344_t1;
go

drop schema babel_4344_s2;
go

drop table αγάπη.abc;
go

drop schema αγάπη;
go

drop table スキーマ.abc;
go

drop schema スキーマ;
go

drop table "babel_4344 s1"."babel_4344 t1";
go

drop schema "BAbel_4344 s1";
go

drop user babel_4344_u1;
go

drop user αιώνια;
go

drop user ログイン;
go

use master;
go

drop database babel_4344_d1;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'babel_4344_l1' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login babel_4344_l1;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'αιώνια' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login αιώνια;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'ログイン' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login ログイン;
go

-- Test group 1 [guest users and dbo schema]
-- tsql
-- create objects
create login l1 with password = '12345678'
go
create table t1(a int);
go
create view v1 as select 2;
go
create proc p1 as select 1;
go
create function f1() returns int begin declare @a int; set @a = 1; return @a; end 
go

-- tsql user=l1 password=12345678
-- guest user should have no permission
select current_user;
go
select * from dbo.t1;
go
select * from dbo.v1;
go
exec dbo.p1;
go
select * from dbo.f1()
go

-- tsql
grant select, execute on schema::dbo to guest;
go
create function f2() returns int begin declare @a int; set @a = 1; return @a; end 
go

-- tsql user=l1 password=12345678
-- guest user should have select and EXECUTE permission
select current_user;
go
select * from dbo.t1;
go
select * from dbo.v1;
go
exec dbo.p1;
go
select * from dbo.f1()
go
select * from dbo.f2()
go

-- tsql
grant select on dbo.t1 to guest;
go
grant execute on dbo.f1 to guest;
go

-- tsql user=l1 password=12345678
-- guest user should have select and EXECUTE permission
select current_user;
go
select * from dbo.t1;
go
select * from dbo.v1;
go
exec dbo.p1;
go
select * from dbo.f1()
go
select * from dbo.f2()
go

-- tsql
revoke select on dbo.t1 from guest;
go
revoke execute on dbo.f1 from guest;
go
revoke select, execute on schema::dbo to guest;
go

-- tsql user=l1 password=12345678
-- guest user should have no permission
select current_user;
go
select * from dbo.t1;
go
select * from dbo.v1;
go
exec dbo.p1;
go
select * from dbo.f1()
go
select * from dbo.f2()
go

-- tsql
-- drop objects
drop table t1;
go
drop view v1;
go
drop procedure p1;
go
drop function f1;
go
drop function f2;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l1' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l1;
go

-- Create objects for tests in a user defined schema
-- tsql
create schema s1;
go
create login l1 with password = '123';
go
create user u1 for login l1;
go
create login l2 with password = '123';
go
create user u2 for login l2;
go
create table s1.t1(a int);
go
create view s1.v1 as select 1;
go
create procedure s1.p1 as select 1;
go
create function s1.f1() returns int begin declare @a int; set @a = 1; return @a; end
go
create trigger s1.tr1 ON s1.t1 for insert as begin 
select 'insert successful' end
go
create trigger s1.tr2 ON s1.t1 for insert as begin 
grant select on s1.t1 to u1 end
go
create sequence s1.sq1 start with 1 increment by 1 ;
go

-- Test Group 2 [users have no default permission]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
grant select on schema::s1 to u1;
go
grant insert on schema::s1 to u1;
go
grant delete on schema::s1 to u1;
go
grant update on schema::s1 to u1;
go

-- Test Group 3 [user u1 has select, insert, update, delete privilege on the schema]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 2;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
grant execute on schema::s1 to u1;
go

-- Test Group 4 [user u1 has select, insert, update, delete and execute privilege on the schema]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 2;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
-- create new objects in the schema s1
create table s1.t2(a int);
go
create view s1.v2 as select 1;
go
create procedure s1.p2 as select 1;
go
create function s1.f2() returns int begin declare @a int; set @a = 1; return @a; end
go

-- Test Group 5 [u1 has select, insert, update, delete and execute privilege on the schema]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
update s1.t2 set a = 2 where a = 1;
go
delete from s1.t2 where a = 2;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
update s1.t2 set a = 2 where a = 1;
go
delete from s1.t2 where a = 1;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql
revoke select on schema::s1 from u1;
go
revoke insert on schema::s1 from u1;
go
revoke delete on schema::s1 from u1;
go
revoke update on schema::s1 from u1;
go

-- Test Group 6 
-- [user u1 has execute privilege on the schema, u1 has select privilege on s1.t1 via trigger]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 2;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
delete from s1.t2 where a = 1;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
delete from s1.t2 where a = 1;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql
revoke execute on schema::s1 from u1;
go

-- Test Group 7
-- [user u1 and u2 have no privilege on the schema, u1 has select privilege on table s1.t1 via trigger]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
delete from s1.t2 where a = 1;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go
select * from s1.t2;
go
insert into s1.t2 values (1);
go
delete from s1.t2 where a = 1;
go
select * from s1.v2;
go
exec s1.p2;
go
select * from s1.f2()
go

-- tsql
grant select on s1.t1 to u1;
go
grant insert on s1.t1 to u1;
go
grant delete on s1.t1 to u1;
go
grant select on s1.v1 to u1;
go
grant execute on s1.p1 to u1;
go
grant execute on s1.f1 to u1;
go

-- Test Group 8 [user u1 has select, insert, delete, execute privilege on these objects]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
grant select on s1.t1 to PUBLIC;
go
grant insert, delete on s1.t1 to PUBLIC;
go
grant select on s1.v1 to PUBLIC;
go
grant execute on s1.p1 to PUBLIC;
go
grant execute on s1.f1 to PUBLIC;
go

-- Test Group 9 [select, insert, execute privilege on these objects to PUBLIC]
-- [Also, u1 has select, insert and execute privilege on these objects]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
revoke select on s1.t1 from u1;
go
revoke insert, delete on s1.t1 from u1;
go
revoke select on s1.v1 from u1;
go
revoke execute on s1.p1 from u1;
go
revoke execute on s1.f1 from u1;
go

-- Test Group 10 [select, insert, delete, execute privilege on these objects to PUBLIC]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
grant select on s1.t1 to u1;
go
grant insert on s1.t1 to u1;
go
grant delete on s1.t1 to u1;
go
grant select on s1.v1 to u1;
go
grant execute on s1.p1 to u1;
go
grant execute on s1.f1 to u1;
go
revoke select on s1.t1 from public;
go
revoke insert, delete on s1.t1 from public;
go
revoke select on s1.v1 from public;
go
revoke execute on s1.p1 from public;
go
revoke execute on s1.f1 from public;
go

-- Test Group 11 [select, insert, delete, execute privilege on these objects to u1]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
grant select, insert, delete, execute on schema::s1 to public;
go
grant select, insert, delete, execute on schema::s1 to u1;
go

-- Test Group 12
-- [select, insert, delete, execute privilege on these objects to u1]
-- [select, insert, delete, execute privilege on schema to public, u1]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
revoke select, insert, delete, execute on schema::s1 from u1;
go

-- Test Group 13
-- [select, insert, delete, execute privilege on these objects to u1]
-- [select, insert, delete, execute privilege on schema to public]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
revoke select on s1.t1 from u1;
go
revoke insert, delete on s1.t1 from u1;
go
revoke select on s1.v1 from u1;
go
revoke execute on s1.p1 from u1;
go
revoke execute on s1.f1 from u1;
go

-- Test Group 14
-- [select, insert, delete, execute privilege on schema to public]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql
revoke select, insert, delete, execute on schema::s1 from public;
go

-- Test Group 15 [No privilege on these objects]
-- tsql user=l1 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- tsql user=l2 password=123
select current_user;
go
select * from s1.t1;
go
insert into s1.t1 values (1);
go
insert into s1.t1 (a) values (next value for s1.sq1);
go
update s1.t1 set a = 2 where a = 1;
go
delete from s1.t1 where a = 1;
go
select * from s1.v1;
go
exec s1.p1;
go
select * from s1.f1()
go

-- Test Group 16 [Cross database queries]
-- tsql
create database db1;
go
use db1
go
create user u1 for login l1;
go

-- create objects in db1 database
create schema s1;
go
create table s1.t1(a int);
go
create view s1.v1 as select 2;
go
create proc s1.p1 as select 1;
go
create function s1.f1() returns int begin declare @a int; set @a = 1; return @a; end 
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select * from db1.s1.f1();
go

-- tsql
use db1
go
grant select on schema::s1 to u1;
go
grant execute on schema::s1 to u1;
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select db1.s1.f1(); -- Needs fix [BABEL-4841]
go

-- tsql
revoke select on schema::s1 to u1;
go
revoke execute on schema::s1 to u1;
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select * from db1.s1.f1();
go

-- tsql
-- drop objects
use db1
go
drop table s1.t1;
go
drop view s1.v1
go
drop procedure s1.p1
go
drop function s1.f1
go
drop schema s1;
go
drop user u1;
go

use master
go
drop database db1
go

-- Using Collation BBF_Unicode_CP1_CI_AI
-- tsql
create database db1 collate BBF_Unicode_CP1_CI_AI;
go
use db1
go
create user u1 for login l1;
go

-- create objects in db1 database
create schema s1;
go
create table s1.t1(a int);
go
create view s1.v1 as select 2;
go
create proc s1.p1 as select 1;
go
create function s1.f1() returns int begin declare @a int; set @a = 1; return @a; end 
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select * from db1.s1.f1();
go

-- tsql
use db1
go
grant select on schema::s1 to u1;
go
grant execute on schema::s1 to u1;
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select db1.s1.f1(); -- Needs fix [BABEL-4841]
go

-- tsql
revoke select on schema::s1 to u1;
go
revoke execute on schema::s1 to u1;
go

-- tsql user=l1 password=123
-- try to access the objects which belong to db1
use master
go
select current_user;
go
select * from db1.s1.t1;
go
select * from db1.s1.v1;
go
exec db1.s1.p1;
go
select * from db1.s1.f1();
go

-- tsql
-- drop objects
use db1
go
drop table s1.t1;
go
drop view s1.v1
go
drop procedure s1.p1
go
drop function s1.f1
go
drop schema s1;
go
drop user u1;
go

use master
go
drop database db1
go
drop trigger s1.tr1;
go
drop trigger s1.tr2;
go
drop sequence s1.sq1;
go
drop table s1.t1;
go
drop table s1.t2;
go
drop view s1.v1;
go
drop view s1.v2;
go
drop procedure s1.p1;
go
drop procedure s1.p2;
go
drop function s1.f1;
go
drop function s1.f2;
go
drop schema s1;
go
drop user u1;
go
drop user u2;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l1' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l2' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l1;
go

drop login l2;
go

-- Test group 17 [nested tests]
-- create objects
-- tsql
create schema s1;
go
create schema s2;
go
create login l3 with password = '123'
go
create user u3 for login l3
go
create login l4 with password = '123'
go
create user u4 for login l4
go
create table s1.t1(a int);
go
create view s2.v1 as select a from s1.t1; -- table inside a view
go
create proc s2.p1 as select a from s1.t1; -- table inside a proc
go
create function s2.f1() returns table as return (select * from s1.t1); -- table inside a function
go
create proc s1.p1 as select * from s2.v1; -- view inside a proc
go
create function s1.f1() returns table as return (select * from s2.v1); -- view inside a function
go
-- calling a user defined stored proc inside a view is not allowed
-- calling a user defined stored proc inside a function is not allowed
create view s2.v2 as select * from s1.f1(); -- function inside a view
go
create proc s2.p2 as select * from s1.f1(); -- function inside a proc
go
create view s1.v3 as select * from s2.v1; -- view inside a view
go
create proc s2.p3 as begin exec s1.p1 end; -- procedure inside a procedure
go
create function s1.f2() returns int as begin declare @a int set @a = 1 return @a end
go
create function s2.f2() returns int as begin declare @a int set @a = (select s1.f2()) return @a end -- function inside a function
go

-- [u3 and u4 have no privilege]
-- tsql user=l3 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql user=l4 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql
grant select on schema::s1 to u3;
go
grant execute on schema::s1 to u3;
go

-- u3 has select and execute privilege on s1
-- tsql user=l3 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql user=l4 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql
revoke select on schema::s1 to u3;
go
revoke execute on schema::s1 to u3;
go
grant select on schema::s2 to u3;
go
grant execute on schema::s2 to u3;
go

-- u3 has select and execute privilege on s2
-- tsql user=l3 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql user=l4 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql
grant select on schema::s1 to u3;
go
grant execute on schema::s1 to u3;
go
-- check for inconsistent metadata
select COUNT(*) FROM sys.babelfish_inconsistent_metadata();
go

-- u3 has select and execute privilege on s1 and s2
-- tsql user=l3 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql user=l4 password=123
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql
revoke select on schema::s2 to u3;
go
revoke execute on schema::s2 to u3;
go
revoke select on schema::s1 to u3;
go
revoke execute on schema::s1 to u3;
go

-- [u3 and u4 have no privilege]
-- tsql user=l3 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql user=l4 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
select * from s1.v3
go
exec s2.p3;
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go
select s2.f2();
go

-- tsql
-- drop objects
use master
go
drop view s1.v3;
go
drop view s2.v1;
go
drop procedure s1.p1;
go
drop procedure s2.p1;
go
drop view s2.v2;
go
drop table s1.t1;
go
drop function s1.f1;
go
drop function s2.f1;
go
drop function s1.f2;
go
drop function s2.f2;
go
drop procedure s2.p2;
go
drop procedure s2.p3;
go
drop schema s1;
go
drop schema s2;
go
drop user u3;
go
drop user u4;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l3' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l4' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l3;
go

drop login l4;
go

-- Test Group 18 [Where grantor is dbo, but it doesn’t have sysadmin role]
-- tsql
create login l5 with password = '123';
go
create login l6 with password = '123';
go
alter role sysadmin add member l5;
go

-- tsql user=l5 password=123
create database db1
go
use db1
go
select current_user
go
create schema s1;
go
create table s1.t1(a int);
go
use master
go

-- tsql
alter role sysadmin drop member l5;
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
grant select on schema::s1 to guest;
go
use master
go

-- tsql user=l6 password=123
use db1
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
grant connect to guest;
go
use master
go

-- connect permission on database, select permission on schema
-- tsql user=l6 password=123
use db1
go
select * from s1.t1;
go
use master
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
revoke select on schema::s1 from guest
go
use master
go

-- only connect permission on database
-- tsql user=l6 password=123
use db1
go
select * from s1.t1;
go
use master
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
revoke connect from guest
go
use master
go

-- tsql user=l5 password=123
use db1
go
drop table s1.t1;
go
drop schema s1;
go
use master
go

-- tsql
use master
go
drop database db1
go
-- Using Collation BBF_Unicode_CP1_CI_AI

-- tsql user=l5 password=123
create database db1 collate BBF_Unicode_CP1_CI_AI
go
use db1
go
select current_user
go
create schema s1;
go
create table s1.t1(a int);
go
use master
go

-- tsql
alter role sysadmin drop member l5;
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
grant select on schema::s1 to guest;
go
use master
go

-- tsql user=l6 password=123
use db1
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
grant connect to guest;
go
use master
go

-- connect permission on database, select permission on schema
-- tsql user=l6 password=123
use db1
go
select * from s1.t1;
go
use master
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
revoke select on schema::s1 from guest
go
use master
go

-- only connect permission on database
-- tsql user=l6 password=123
use db1
go
select * from s1.t1;
go
use master
go

-- tsql user=l5 password=123
use db1
go
select current_user
go
revoke connect from guest
go
use master
go

-- tsql user=l5 password=123
use db1
go
drop table s1.t1;
go
drop schema s1;
go
use master
go

-- tsql
use master
go
drop database db1
go
-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l5' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l6' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l5;
go
drop login l6;
go

-- test drop database removes correct entries from the catalog
-- tsql
create table babel_4344_t1(a int);
go
grant select on babel_4344_t1 to guest;
go
create database babel_4344_d1;
go
use babel_4344_d1;
go
create table babel_4344_t1(a int);
go
grant select on babel_4344_t1 to guest;
go
use master;
go

-- psql
-- should have 2 entries for master and babel_4344_d1 databases
select schema_name, object_name, permission, grantee from sys.babelfish_schema_permissions where object_name = 'babel_4344_t1';
go

-- tsql
use master
go
drop database babel_4344_d1;
go
-- Using Collation BBF_Unicode_CP1_CI_AI
create database babel_4344_d1 collate BBF_Unicode_CP1_CI_AI;
go
use babel_4344_d1;
go
create table babel_4344_t1(a int);
go
grant select on babel_4344_t1 to guest;
go
use master;
go

-- psql
-- should have 2 entries for master and babel_4344_d1 databases
select schema_name, object_name, permission, grantee from sys.babelfish_schema_permissions where object_name = 'babel_4344_t1';
go

-- tsql
use master
go
drop database babel_4344_d1;
go

-- psql
-- should have 1 entry for master database since babel_4344_d1 is dropped
select schema_name, object_name, permission, grantee from sys.babelfish_schema_permissions where object_name = 'babel_4344_t1';
go

-- tsql
drop table babel_4344_t1;
go

-- psql
-- should have no entries since the table is dropped
select schema_name, object_name, permission, grantee from sys.babelfish_schema_permissions where object_name = 'babel_4344_t1';
go

-- tsql
-- should properly throw an error when schema does not exist
GRANT SELECT on doesnt_exist.tbl TO public;
GO

grant execute on xyz.babel_4344_p to public;
GO
