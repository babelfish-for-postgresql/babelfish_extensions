-- Test group 18 [nested tests]
-- create objects
-- tsql
create schema s1;
go
create schema s2;
go
create login l1 with password = '123'
go
create user u1 for login l1
go
create login l2 with password = '123'
go
create user u2 for login l2
go
create table s1.t1(a int);
go
create view s2.v1 as select a from s1.t1; -- table inside a view
go
create proc s2.p1 as select a from s1.t1; -- table inside a proc
go
create function s2.f1() returns table as return (select * from s1.t1); -- table inside a function
go
create proc s1.p1 as select * from s2.v1; -- view inside a proc
go
create function s1.f1() returns table as return (select * from s2.v1); -- view inside a function
go
-- calling a user defined stored proc inside a view is not allowed
-- calling a user defined stored proc inside a function is not allowed
create view s2.v2 as select * from s1.f1(); -- function inside a view
go
create proc s2.p2 as select * from s1.f1(); -- function inside a proc
go

-- [u1 and u2 have no privilege]
-- tsql user=l1 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql user=l2 password=123
select current_user;
go
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql
grant select on schema::s1 to u1;
go
grant execute on schema::s1 to u1;
go

-- u1 has select and execute privilege on s1
-- tsql user=l1 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql user=l2 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql
revoke select on schema::s1 to u1;
go
revoke execute on schema::s1 to u1;
go
grant select on schema::s2 to u1;
go
grant execute on schema::s2 to u1;
go

-- u1 has select and execute privilege on s2
-- tsql user=l1 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql user=l2 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql
grant select on schema::s1 to u1;
go
grant execute on schema::s1 to u1;
go

-- u1 has select and execute privilege on s1 and s2
-- tsql user=l1 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql user=l2 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql
revoke select on schema::s2 to u1;
go
revoke execute on schema::s2 to u1;
go
revoke select on schema::s1 to u1;
go
revoke execute on schema::s1 to u1;
go

-- u1 has select and execute privilege
-- tsql user=l1 password=123
select * from s2.v1
go
select * from s2.v2
go
exec s1.p1;
go
exec s2.p1;
go
exec s2.p2;
go
select s1.f1();
go
select s2.f1();
go

-- tsql
-- drop objects
use master
go
drop view s2.v1;
go
drop procedure s1.p1;
go
drop procedure s2.p1;
go
drop view s2.v2;
go
drop table s1.t1;
go
drop function s1.f1;
go
drop function s2.f1;
go
drop procedure s2.p2;
go
drop schema s1;
go
drop schema s2;
go
drop user u1;
go
drop user u2;
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l1' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l2' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l1;
go

drop login l2;
go

-- Test Group 19 [Where grantor is dbo, but it doesnâ€™t have sysadmin role]
-- tsql
create login l3 with password = '123';
go
create login l4 with password = '123';
go
alter role sysadmin add member l3;
go

-- tsql user=l3 password=123
create database db1
go
use db1
go
select current_user
go
create schema s1;
go
create table s1.t1(a int);
go
use master
go

-- tsql
alter role sysadmin drop member l3;
go

-- tsql user=l3 password=123
use db1
go
select current_user
go
grant select on schema::s1 to guest;
go
use master
go

-- tsql user=l4 password=123
use db1
go

-- tsql user=l3 password=123
use db1
go
drop table s1.t1;
go
drop schema s1;
go
use master
go

-- tsql
use master
go
drop database db1
go

-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l3' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'l4' AND backend_type = 'client backend' AND usesysid IS NOT NULL;
go

-- Wait to sync with another session
SELECT pg_sleep(1);
go

-- tsql
drop login l3;
go
drop login l4;
go