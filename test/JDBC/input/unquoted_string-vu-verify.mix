-- BABEL-334: Support unquoted string parameter values in procedure calls/declarations

-- tsql

-- unquoted strings in procedure call arguments
create procedure unqStr_proc_1(@par1 varchar(20), @par2 varchar(20))
as 
select @par1, @par2
go
-- should print strings:
exec unqStr_proc_1 abc, def$ghi
go
exec unqStr_proc_1 abc, 'this is a string'
go
exec unqStr_proc_1 'this is a string', def
go
exec unqStr_proc_1 abc#def, null
go
exec unqStr_proc_1 @par1=abc$def, @par2=null
go
exec unqStr_proc_1 @par1=null, @par2=abc#def
go
-- should print strings, bracketed identifiers are also interpreted as unquoted strings in SQL Server:
exec unqStr_proc_1 [abc], [def$ghi]
go
-- should print strings, bracketed identifiers as procedure args are also interpreted as unquoted strings in SQL Server:
set quoted_identifier on
go
exec unqStr_proc_1 "abc", "def$ghi"
go
set quoted_identifier off
go
-- now they are just regular double-quoted strings:
exec unqStr_proc_1 "abc abc", "def ?! ghi"
go
-- should raise error since 'user' is a function and not allowed as argument
exec unqStr_proc_1 user, 'abc'
go
exec unqStr_proc_1 @par1=user, @par2='abc'
go
-- should raise error because the unquoted argument cannot be interpreted as a string:
exec unqStr_proc_1 abc, def.ghi
go
exec unqStr_proc_1 abc, def~ghi
go

-- should print contents of variables:
declare @myvar varchar(20), @myvar2 varchar(20) = 'this is myvar2'
exec unqStr_proc_1 @myvar, @myvar2
exec unqStr_proc_1 @par1=@myvar2, @par2=@myvar
go
exec unqStr_proc_1 @@language, @@servicename
go

-- should print variable names with leading space:
exec unqStr_proc_1 [ @@language], [ @@servicename]
go

-- should print arguments as strings
exec unqStr_proc_1 '[@@language]', '[@@servicename]'
go
exec unqStr_proc_1 '@@language', '@@servicename'
go

-- should print variables names, not their contents
-- however, this does not work correctly in Babelfish: it raises error 'column "@@language" does not exist' 
-- both before and after the fix of unquoted strings in BABEL-334
exec unqStr_proc_1 [@@language], [@@servicename]
go

-- unlike T-SQL procedure calls, function call arguments do not support unquoted strings
create function unqStr_func_1(@par varchar(20)) 
returns varchar(20) 
as begin 
return @par
end
go
-- should return column value:
select dbo.unqStr_func_1(abc) from unqStr_tab  
go
select dbo.unqStr_func_1([abc]) from unqStr_tab  
go
-- should return NULL
select dbo.unqStr_func_1(null) from unqStr_tab  
go
select dbo.unqStr_func_1(null)
go
set quoted_identifier on
go
select dbo.unqStr_func_1("abc") from unqStr_tab  
go
set quoted_identifier off
go
-- now it's just a regular double-quoted string:
select dbo.unqStr_func_1("abc") from unqStr_tab  
go
-- should fail:
select dbo.unqStr_func_1(abc) 
go
select dbo.unqStr_func_1([abc]) 
go
set quoted_identifier on
go
-- should fail:
select dbo.unqStr_func_1("abc") 
go
set quoted_identifier off
go
-- now it's just a regular double-quoted string:
select dbo.unqStr_func_1("abc") 
go

-- unquoted string in parameter declaration
create proc unqStr_proc_2 @par1 varchar(20) = abc
as
select @par1
go
-- should print 'abc':
exec unqStr_proc_2
go

-- 'user' is handled as function call
create proc unqStr_proc_3 @par1 varchar(20) = user
as
select @par1
go
-- should print 'dbo':
exec unqStr_proc_3 
go

create function unqStr_func_2(@par1 varchar(20) = abc) 
returns varchar(20)
as
begin
return @par1
end
go
-- should reflect column value:
select dbo.unqStr_func_2(abc) from unqStr_tab  
go
-- should print 'dbo', since 'user' is a function call
select dbo.unqStr_func_2(user)
go
-- should print 'abc':
declare @v varchar(20)
execute @v = unqStr_func_2
select @v
go
-- this test will fail since 'default' arguments are not yet supported in Babelfish (BABEL-335)
-- once supported, should print 'abc':
select dbo.unqStr_func_2(default) 
go

-- should print value of @@language:
create procedure unqStr_proc_4 @p1 varchar(20) = @@language as select @p1
go
exec unqStr_proc_4
go

-- as a default, @p2 should take value of @p1.
-- however this does not work in Babelfish, both before and after 
-- the fix for unquoted strings in BABEL-334
create procedure unqStr_proc_5 @p1 varchar(20), @p2 varchar(20) = @p1
as select @p2
go
exec unqStr_proc_5 'this is @p1'
go

-- should raise error:
create procedure unqStr_proc_6 @p0 varchar(20) = @@myvar
as select @p1
go

-- variable as column default is invalid syntax in SQL Server, but works in Babelfish, which is harmless
-- in Babelfish this only works for a global (@@) variable, not for a local variable
create function unqStr_func_3 (@p1 varchar(20) = @@language) returns varchar(20)
as 
begin
return @p1
end
go

-- this will not work until 'default' arguments are supported (BABEL-335)
select dbo.unqStr_func_3(default)
go

-- should print value of @@language:
declare @v varchar(20)
exec @v = unqStr_func_3
select @v
go

-- invalid in SQL Server, should also fail in Babelfish:
create function unqStr_func_4 (@p1 varchar(20), @p2 varchar(20) = @p1) returns varchar(20)
as
begin
return @p2
end
go

-- psql

-- PG test cases

-- call T-SQL proc from PG, T-SQL semantics still apply
-- should print 'abc':
-- NOTE: test is disabled as it crashes the JDBC test framework with message 'Received resultset tuples, but no field structure for them'
--call master_dbo.unqStr_proc_2();
--go

-- PG procedure/function calls should not be affected by the T-SQL fix 
-- for unquoted strings in BABEL-334
CREATE OR REPLACE PROCEDURE unqStr_pgproc_1(par1 varchar(20))
LANGUAGE plpgsql
AS $$
begin
raise notice 'arg=[%]', par1;
end
$$;
go
-- should print 'abc':
CALL unqStr_pgproc_1('abc');
go
-- should raise an error about column not found:
CALL unqStr_pgproc_1(abc);
go

CREATE function unqStr_pgfunc_1(par1 name) 
returns varchar(20)
LANGUAGE plpgsql
AS $$
begin
return par1;
end
$$;
go
-- should print 'abc':
select unqStr_pgfunc_1('abc'); 
go
-- should print column value:
select unqStr_pgfunc_1(abc) from master_dbo.unqStr_tab;
go
-- should raise an error about column not found:
select unqStr_pgfunc_1(abc);
go
-- should print 'jdbc_user', since 'user' is a function call:
select unqStr_pgfunc_1(user);
go

-- should fail since PG does not support unquoted string defaults:
CREATE OR REPLACE PROCEDURE unqStr_pgproc_2(par1 varchar(20) = abc)
LANGUAGE plpgsql
AS $$
begin
raise notice 'arg=[%]', par1;
end
$$;
go

-- should fail since PG does not support unquoted string defaults:
CREATE function unqStr_pgfunc_2(par1 varchar(20) = abc) 
returns varchar(20)
LANGUAGE plpgsql
AS $$
begin
return par1;
end
$$;
go

