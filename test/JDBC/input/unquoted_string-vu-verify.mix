-- BABEL-334: Support unquoted string parameter values in procedure calls/declarations
-- This also exercises parts of the ANTLR parse tree rewriting

-- tsql

-- unquoted strings in procedure call arguments
create procedure unqStr_proc_1(@par1 varchar(100), @par2 varchar(100))
as 
select @par1, @par2
go
-- should print strings:
exec unqStr_proc_1 aBc, def$ghi
go
exec unqStr_proc_1 aBc, 'this is a string'
go
exec unqStr_proc_1 'this is a string', def
go
exec unqStr_proc_1 aBc#def, null
go
exec unqStr_proc_1 @par1=aBc$def, @par2=null
go
execute unqStr_proc_1 @par1=aBc$def, @par2=null
go
exec unqStr_proc_1 @par1=null, @par2=aBc#def
go
execute unqStr_proc_1 @par1=null, @par2=aBc#def
go
-- should print strings, bracketed identifiers are also interpreted as unquoted strings in SQL Server:
exec unqStr_proc_1 [aBc], [def$ghi]
go
-- should print strings, bracketed identifiers as procedure args are also interpreted as unquoted strings in SQL Server:
set quoted_identifier on
go
exec unqStr_proc_1 "aBc", "def$ghi"
go
execute unqStr_proc_1 "aBc", "def$ghi"
go
-- strings longer than 63 should not be truncated, hashed or downcased
exec unqStr_proc_1 a23456789B123456789C123456789d123456789E123456789F123456789G123456789H, AaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaB
go
execute    unqStr_proc_1     @par1 = a23456789B123456789C123456789d123456789E123456789F123456789G123456789H, @par2=AaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaB
go

set quoted_identifier off
go
-- now they are just regular double-quoted strings:
exec unqStr_proc_1 "aBc aBc", "def ?! ghi"
go
-- should raise error since 'user' is a function and not allowed as argument
exec unqStr_proc_1 user, 'aBc'
go
exec unqStr_proc_1 @par1=user, @par2='aBc'
go
-- should raise error because the unquoted argument cannot be interpreted as a string:
exec unqStr_proc_1 aBc, def.ghi
go
exec unqStr_proc_1 aBc, def~ghi
go


-- should print contents of variables:
declare @myvar varchar(20), @myvar2 varchar(20) = 'this is myvar2'
exec unqStr_proc_1 @myvar, @myvar2
exec unqStr_proc_1 @par1=@myvar2, @par2=@myvar
go
exec unqStr_proc_1 @@language, @@servicename
go

-- should print variable names with leading space:
exec unqStr_proc_1 [ @@language], [ @@servicename]
go

-- should print arguments as strings
exec unqStr_proc_1 '[@@language]', '[@@servicename]'
go
exec unqStr_proc_1 '@@language', '@@servicename'
go

-- should print variables names, not their contents
-- however, this does not work correctly in Babelfish: it raises error 'column "@@language" does not exist' 
-- both before and after the fix of unquoted strings in BABEL-334
exec unqStr_proc_1 [@@language], [@@servicename]
go

-- unlike T-SQL procedure calls, function call arguments do not support unquoted strings
create function unqStr_func_1(@par varchar(20)) 
returns varchar(20) 
as begin 
return @par
end
go
-- should return column value:
select dbo.unqStr_func_1(aBc) from unqStr_tab  
go
select dbo.unqStr_func_1([aBc]) from unqStr_tab  
go
-- should return NULL
select dbo.unqStr_func_1(null) from unqStr_tab  
go
select dbo.unqStr_func_1(null)
go
set quoted_identifier on
go
select dbo.unqStr_func_1("aBc") from unqStr_tab  
go
set quoted_identifier off
go
-- now it's just a regular double-quoted string:
select dbo.unqStr_func_1("aBc") from unqStr_tab  
go
-- should fail:
select dbo.unqStr_func_1(aBc) 
go
select dbo.unqStr_func_1([aBc]) 
go
set quoted_identifier on
go
-- should fail:
select dbo.unqStr_func_1("aBc") 
go
set quoted_identifier off
go
-- now it's just a regular double-quoted string:
select dbo.unqStr_func_1("aBc") 
go

-- unquoted string in parameter declaration
create proc unqStr_proc_2 @par1 varchar(20) = aBc
as
select @par1
go
-- should print 'aBc':
exec unqStr_proc_2
go

-- strings longer than 63 should not be truncated, hashed or downcased
create procedure unqStr_proc_2a(
@par1 varchar(100) = a23456789B123456789C123456789d123456789E123456789F123456789G123456789H, 
@par2 varchar(100) = [AaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaB])
as 
select @par1, @par2
go
set quoted_identifier on
go
exec unqStr_proc_2a
go
set quoted_identifier off
go
exec unqStr_proc_2a
go

create procedure unqStr_proc_2b(
@par1 varchar(20) = [Aaa aaB],
@par2 varchar(20) = [Aa"bB'cC])
as 
select @par1, @par2
go
set quoted_identifier on
go
exec unqStr_proc_2b
go
set quoted_identifier off
go
exec unqStr_proc_2b
go

set quoted_identifier off
go
create procedure unqStr_proc_2c(
@par1 varchar(20) = "[Aaa aaB]",
@par2 varchar(20) = "[Aa""bB'cC]")
as 
select @par1, @par2
go
set quoted_identifier on
go
exec unqStr_proc_2c
go
exec unqStr_proc_2c "[Xxx xxyZ]", "[Xx""yY'zZ]"
go
set quoted_identifier off
go
exec unqStr_proc_2c
go
exec unqStr_proc_2c "[Xxx xxyZ]", "[Xx""yY'zZ]"
go

set quoted_identifier on
go
create procedure unqStr_proc_2d(
@par1 varchar(20) = "[Aaa aaB]",
@par2 varchar(20) = "[Aa""bB'cC]")
as 
select @par1, @par2
go
set quoted_identifier on
go
exec unqStr_proc_2d
go
exec unqStr_proc_2d "[Xxx xxyZ]", "[Xx""yY'zZ]"
go
set quoted_identifier off
go
exec unqStr_proc_2d
go
exec unqStr_proc_2d "[Xxx xxyZ]", "[Xx""yY'zZ]"
go

set quoted_identifier off
go
create procedure unqStr_proc_2e(
@par1 varchar(20) = ["Aaa aaB"],
@par2 varchar(20) = ["Aa"bB'cC"])
as 
select @par1, @par2
go
set quoted_identifier on
go
exec unqStr_proc_2e
go
exec unqStr_proc_2e ["Xxx xxyZ"], ["Xx""yY'zZ"]
go
set quoted_identifier off
go
exec unqStr_proc_2e
go
exec unqStr_proc_2e ["Xxx xxyZ"], ["Xx""yY'zZ"]
go

-- empty bracketed identifier raises error in SQL Server, but succeeds in Babelfish,
-- both before and after the fix for BABEL-334
exec unqStr_proc_2e [], 'x'
go

-- double-quoted/bracketed datatype:
set quoted_identifier off
go
-- should raise error
create procedure unqStr_proc_2f(@par1 "varchar"(20) = aBc)
as 
select @par1
go
create procedure unqStr_proc_2g(@par1 [varchar](20) = aBc)
as 
select @par1
go
exec unqStr_proc_2g
go
set quoted_identifier on
go
create procedure unqStr_proc_2h(@par1 "varchar"(20) = aBc)
as 
select @par1
go
exec unqStr_proc_2h
go
create procedure unqStr_proc_2i(@par1 [varchar](20) = aBc)
as 
select @par1
go
exec unqStr_proc_2i
go
set quoted_identifier off
go

-- 'user' is handled as function call in Babelfish, though it fails in SQL Server
create proc unqStr_proc_3 @par1 varchar(20) = user
as
select @par1
go
-- should print 'dbo':
exec unqStr_proc_3 
go

create function unqStr_func_2(@par1 varchar(20) = aBc) 
returns varchar(20)
as
begin
return @par1
end
go
-- should reflect column value:
select dbo.unqStr_func_2(aBc) from unqStr_tab  
go
-- should print 'dbo', since 'user' is a function call
select dbo.unqStr_func_2(user)
go
-- should print 'aBc':
declare @v varchar(20)
execute @v = unqStr_func_2
select @v
go
-- this test will fail since 'default' arguments are not yet supported in Babelfish (BABEL-335)
-- once supported, should print 'aBc':
select dbo.unqStr_func_2(default) 
go

-- should print value of @@language:
create procedure unqStr_proc_4 @p1 varchar(20) = @@language as select @p1
go
exec unqStr_proc_4
go

-- as a default, @p2 should take value of @p1.
-- however this does not work in Babelfish, both before and after 
-- the fix for unquoted strings in BABEL-334
create procedure unqStr_proc_5 @p1 varchar(20), @p2 varchar(20) = @p1
as select @p2
go
exec unqStr_proc_5 'this is @p1'
go

-- should raise error:
create procedure unqStr_proc_6 @p0 varchar(20) = @@myvar
as select @p1
go

-- variable as column default is invalid syntax in SQL Server, but works in Babelfish, which is harmless
-- in Babelfish this only works for a global (@@) variable, not for a local variable
create function unqStr_func_3 (@p1 varchar(20) = @@language) returns varchar(20)
as 
begin
return @p1
end
go

-- this will not work until 'default' arguments are supported (BABEL-335)
select dbo.unqStr_func_3(default)
go

-- should print value of @@language:
declare @v varchar(20)
exec @v = unqStr_func_3
select @v
go

-- invalid in SQL Server, should also fail in Babelfish:
create function unqStr_func_4 (@p1 varchar(20), @p2 varchar(20) = @p1) returns varchar(20)
as
begin
return @p2
end
go

-- psql

-- PG test cases

-- call T-SQL proc from PG, T-SQL semantics still apply
-- should print 'aBc':
-- NOTE: test is disabled as it crashes the JDBC test framework with message 'Received resultset tuples, but no field structure for them'
--call master_dbo.unqStr_proc_2();
--go

-- PG procedure/function calls should not be affected by the T-SQL fix 
-- for unquoted strings in BABEL-334
CREATE OR REPLACE PROCEDURE unqStr_pgproc_1(par1 varchar(20))
LANGUAGE plpgsql
AS $$
begin
raise notice 'arg=[%]', par1;
end
$$;
go
-- should print 'aBc':
CALL unqStr_pgproc_1('aBc');
go
-- should raise an error about column not found:
CALL unqStr_pgproc_1(aBc);
go

CREATE function unqStr_pgfunc_1(par1 varchar(20)) 
returns varchar(20)
LANGUAGE plpgsql
AS $$
begin
return par1;
end
$$;
go
-- should print 'aBc':
select unqStr_pgfunc_1('aBc'); 
go
-- should print column value:
select unqStr_pgfunc_1(aBc) from master_dbo.unqStr_tab;
go
-- should raise an error about column not found:
select unqStr_pgfunc_1(aBc);
go
-- should print 'jdbc_user', since 'user' is a function call:
select unqStr_pgfunc_1(user);
go

-- should fail since PG does not support unquoted string defaults:
CREATE OR REPLACE PROCEDURE unqStr_pgproc_2(par1 varchar(20) = aBc)
LANGUAGE plpgsql
AS $$
begin
raise notice 'arg=[%]', par1;
end
$$;
go

-- should fail since PG does not support unquoted string defaults:
CREATE function unqStr_pgfunc_2(par1 varchar(20) = aBc) 
returns varchar(20)
LANGUAGE plpgsql
AS $$
begin
return par1;
end
$$;
go

