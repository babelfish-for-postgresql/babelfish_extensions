-- For STEquals
DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
DECLARE @point2 geometry = geometry::Point(3.0, 4.0, 4326);
SELECT @point1.STEquals(@point2) AS Equal;
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
DECLARE @point2 geometry = geometry::Point(3.0, 4.0, 4326);
SELECT STEquals(@point1, @point2);
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
DECLARE @point2 geometry = geometry::Point(3.0, 4.0, 4326);
SELECT @point1 . STEquals ( @point2 );
go
~~START~~
bit
0
~~END~~


SELECT PointColumn1.STEquals(PointColumn2) AS Equals FROM YourTable2;
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
SELECT PointColumn1.STEquals(@point1) AS Equals FROM YourTable2;
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
SELECT @point1.STEquals(PointColumn2) AS Equals FROM YourTable2;
go
~~START~~
bit
0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @isEqual BIT = 1;
SELECT * FROM YourTable WHERE PointColumn.STEquals(@referencePoint) = @isEqual;
go
~~START~~
int#!#geometry
~~END~~


SELECT ID, PointColumn1.STEquals(PointColumn2) AS Equal_points FROM YourTable2;
go
~~START~~
int#!#bit
1#!#0
~~END~~


SELECT * FROM TableA JOIN TableB ON PointA.STEquals(TableB.PointB) <= 1;
go
~~START~~
int#!#geometry#!#int#!#geometry
1#!#E6100000010C000000000000F03F0000000000000040#!#1#!#E6100000010C00000000000008400000000000001040
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM TableA JOIN TableB ON @referencePoint.STEquals(TableB.PointB) <= 1;
go
~~START~~
int#!#geometry#!#int#!#geometry
1#!#E6100000010C000000000000F03F0000000000000040#!#1#!#E6100000010C00000000000008400000000000001040
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM TableA JOIN TableB ON PointA.STEquals(@referencePoint) <= 1;
go
~~START~~
int#!#geometry#!#int#!#geometry
1#!#E6100000010C000000000000F03F0000000000000040#!#1#!#E6100000010C00000000000008400000000000001040
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable ORDER BY @referencePoint.STEquals(PointColumn);
go
~~START~~
int#!#geometry
1#!#E6100000010C00000000000008400000000000001040
2#!#E6100000010C00000000000014400000000000001840
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable ORDER BY PointColumn.STEquals(@referencePoint);
go
~~START~~
int#!#geometry
1#!#E6100000010C00000000000008400000000000001040
2#!#E6100000010C00000000000014400000000000001840
~~END~~


SELECT * FROM YourTable2 ORDER BY PointColumn1.STEquals(PointColumn2);
go
~~START~~
int#!#geometry#!#geometry
1#!#E6100000010C00000000000008400000000000001040#!#E6100000010C00000000000010400000000000001440
~~END~~


DECLARE @isEqual BIT = 1;
SELECT ID, PointColumn1.STEquals(PointColumn2) AS isEqual,
CASE WHEN PointColumn1.STEquals(PointColumn2) = @isEqual THEN 'yes' ELSE 'no'
END AS isEqual
FROM YourTable2;
go
~~START~~
int#!#bit#!#text
1#!#0#!#no
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
WITH EqualCTE AS ( SELECT ID, PointColumn.STEquals(@referencePoint) AS Equality FROM YourTable)
SELECT * FROM EqualCTE WHERE Equality <= 1;
go
~~START~~
int#!#bit
1#!#0
2#!#0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326); 
UPDATE YourTable SET PointColumn = @referencePoint
WHERE PointColumn.STEquals(@referencePoint) != 1;
go
~~ROW COUNT: 2~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326); 
UPDATE YourTable SET PointColumn = @referencePoint
WHERE @referencePoint.STEquals(PointColumn) = 1;
go
~~ROW COUNT: 2~~



DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
WITH EqualCTE AS ( SELECT ID, PointColumn.STEquals(@referencePoint) AS Equal FROM YourTable ORDER BY PointColumn.STX)
SELECT * FROM EqualCTE WHERE Equal <= 1.0 ORDER BY Equal;
GO
~~START~~
int#!#bit
1#!#1
2#!#1
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
WITH EqualCTE AS ( SELECT ID, @referencePoint.STEquals(PointColumn) AS Equal FROM YourTable ORDER BY PointColumn.STX)
SELECT * FROM EqualCTE WHERE Equal <= 1.0 ORDER BY Equal;
GO
~~START~~
int#!#bit
1#!#1
2#!#1
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @isEqual BIT = 1;
SELECT ID, PointColumn.STEquals(@referencePoint) AS EqualityReferencePoint,
CASE WHEN PointColumn.STEquals(@referencePoint) <= @isEqual THEN 'Close'
ELSE 'Far'
END AS Proximity
FROM YourTable;
go
~~START~~
int#!#bit#!#text
1#!#1#!#Close
2#!#1#!#Close
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, @referencePoint.STEquals(PointColumn) AS EqualityReferencePoint,
CASE WHEN @referencePoint.STEquals(PointColumn) <= @referencePoint.STY THEN 'Close'
ELSE 'Far'
END AS Proximity
FROM YourTable;
go
~~START~~
int#!#bit#!#text
1#!#1#!#Far
2#!#1#!#Far
~~END~~


DECLARE @Ranges TABLE (MinDistance float, MaxDistance float);
INSERT INTO @Ranges VALUES (0, 5), (5, 10), (10, 15);
SELECT * FROM ( SELECT ID,
CASE WHEN PointColumn1.STEquals(PointColumn2) BETWEEN 0 AND 1 THEN 'yes'
ELSE 'no'
END AS Range
FROM YourTable2
) AS Source
PIVOT ( COUNT(ID) FOR Range IN ([0-5], [5.1-10], [10.1-15], [15.1+])) AS PivotTable;
go
~~ROW COUNT: 3~~

~~START~~
int#!#int#!#int#!#int
0#!#0#!#0#!#0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STEquals(@referencePoint) AS Equality FROM <YourDatabase>.dbo.YourTable;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '<' at line 2 and character position 66)~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STEquals(@referencePoint) AS Equal,
JSON_QUERY('{"Equal":' + CAST(PointColumn.STEquals(@referencePoint) AS NVARCHAR(MAX)) + '}') AS Json
FROM YourTable;
go
~~START~~
int#!#bit#!#nvarchar
1#!#1#!#{"Equal": 1}
2#!#1#!#{"Equal": 1}
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, @referencePoint.STEquals(PointColumn) AS Equal,
JSON_QUERY('{"Equal":' + CAST(@referencePoint.STEquals(PointColumn) AS NVARCHAR(MAX)) + '}') Json
FROM YourTable;
go
~~START~~
int#!#bit#!#nvarchar
1#!#1#!#{"Equal": 1}
2#!#1#!#{"Equal": 1}
~~END~~


SELECT [PointColumn1].STEquals([PointColumn2]) AS Equality FROM [YourTable2];
go
~~START~~
bit
0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @isEqual BIT = 1;
DECLARE @sql NVARCHAR(MAX);
DECLARE @params NVARCHAR(MAX);
SET @sql = N'
SELECT ID, PointColumn.STEquals(@referencePoint) AS EqualityReferencePoint,
CASE WHEN PointColumn.STEquals(@referencePoint) <= @isEqual THEN ''Close''
ELSE ''Far''
END AS Proximity
FROM YourTable
WHERE PointColumn.STEquals(@referencePoint) <= @isEqual;';
SET @params = N'@referencePoint geometry, @isEqual float';
EXEC sp_executesql @sql, @params, @referencePoint, @isEqual;
go
~~START~~
int#!#bit#!#text
1#!#1#!#Close
2#!#1#!#Close
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT PointColumn.STEquals(@referencePoint) AS Equality FROM YourTable;
SELECT YourTable.PointColumn.STEquals(@referencePoint) AS Equality FROM YourTable;
SELECT dbo.YourTable.PointColumn.STEquals(@referencePoint) AS Equality FROM YourTable;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Remote procedure/function reference with 4-part object name is not currently supported in Babelfish)~~


DECLARE @pnt geometry;
SET @pnt = geometry::STGeomFromText('POINT(-122.34900 47.65100)', 4326);
select geometry::Point(@pnt.STY, @pnt.STX, 4326).STEquals(@pnt)
go
~~START~~
bit
0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @equal BIT = 1;
SELECT ROUND(PointColumn.STEquals(@referencePoint) / @equal, 0) * @equal AS Equalitygroup,
COUNT(*) AS PointCount
FROM YourTable
GROUP BY ROUND(PointColumn.STEquals(@referencePoint) / @equal, 0) * @equal
ORDER BY Equalitygroup;
GO
~~START~~
numeric#!#int
1#!#2
~~END~~


DECLARE @referencePoint geometry = geometry::Point(1.0, 0.0, 4326);
SELECT ROUND(PointColumn.STEquals(@referencePoint) / @referencePoint.STX, 0) * @referencePoint.STX AS Equalitygroup,
COUNT(*) AS PointCount
FROM YourTable
GROUP BY ROUND(PointColumn.STEquals(@referencePoint) / @referencePoint.STX, 0) * @referencePoint.STX
ORDER BY Equalitygroup;
GO
~~START~~
float#!#int
0.0#!#2
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn1.STEquals(PointColumn2) AS equal,
cast(PointColumn1.STEquals(@referencePoint) as float) - LAG(PointColumn1.STEquals(PointColumn2)) OVER (ORDER BY ID) AS Equalitygroup 
FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: cannot cast type "bit" to double precision)~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STEquals(@referencePoint) AS equal,
cast(@referencePoint.STContains(PointColumn) as float) - LAG(@referencePoint.STX) OVER (ORDER BY ID) AS Equalitygroup
FROM YourTable ORDER BY PointColumn.STX;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: cannot cast type "bit" to double precision)~~






--For STContains
DECLARE @point1 geometry, @point2 geometry;
SET @point1 = geometry::STPointFromText('POINT(-122.34900 47.65100)', 4326);
SET @point2 = geometry::STGeomFromText('POINT(-122.35000 47.65000)', 4326);
SELECT STContains(@point1, @point2);
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry, @point2 geometry;
SET @point1 = geometry::STPointFromText('POINT(-122.34900 47.65100)', 4326);
SET @point2 = geometry::STGeomFromText('POINT(-122.35000 47.65000)', 4326);
SELECT @point1.STContains(@point2);
go
~~START~~
bit
0
~~END~~


DECLARE @point1 geometry, @point2 geometry;
SET @point1 = geometry::STPointFromText('POINT(-122.34900 47.65100)', 4326);
SET @point2 = geometry::STGeomFromText('POINT(-122.35000 47.65000)', 4326);
SELECT @point1 . STContains ( @point2 );
Go
~~START~~
bit
0
~~END~~


SELECT ID, PointColumn1.STContains(PointColumn2) AS contain FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~START~~
int#!#bit
1#!#0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
SELECT ID, PointColumn1.STContains(@point1) AS contain FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~START~~
int#!#bit
1#!#0
~~END~~


DECLARE @point1 geometry = geometry::Point(1.0, 2.0, 4326);
SELECT ID, @point1.STContains(PointColumn2) AS contain FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~START~~
int#!#bit
1#!#0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @contain BIT = 1;
SELECT * FROM YourTable WHERE PointColumn.STContains(@referencePoint) <= @contain ORDER BY PointColumn.STX;
GO
~~START~~
int#!#geometry
1#!#E6100000010C00000000000000000000000000000000
2#!#E6100000010C00000000000000000000000000000000
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable WHERE @referencePoint.STContains(PointColumn) <= @referencePoint.STX ORDER BY PointColumn.STX;
GO
~~START~~
int#!#geometry
~~END~~


SELECT ID, PointColumn1.STContains(PointColumn2) AS contain FROM YourTable2;
go
~~START~~
int#!#bit
1#!#0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable WHERE PointColumn.STContains(@referencePoint) != @referencePoint.STX ORDER BY PointColumn.STX;
GO
~~START~~
int#!#geometry
1#!#E6100000010C00000000000000000000000000000000
2#!#E6100000010C00000000000000000000000000000000
~~END~~


SELECT * FROM TableA JOIN TableB ON PointA.STContains(TableB.PointB) = 1 ORDER BY TableB.PointB.STX;
GO
~~START~~
int#!#geometry#!#int#!#geometry
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM TableA JOIN TableB ON @referencePoint.STContains(TableB.PointB) = 1 ORDER BY TableB.PointB.STX;
GO
~~START~~
int#!#geometry#!#int#!#geometry
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM TableA JOIN TableB ON PointA.STContains(@referencePoint) = 1 ORDER BY TableB.PointB.STX;
GO
~~START~~
int#!#geometry#!#int#!#geometry
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM TableA JOIN TableB ON TableB.PointB.STContains(@referencePoint) = 0 ORDER BY TableB.PointB.STX;
GO
~~START~~
int#!#geometry#!#int#!#geometry
1#!#E6100000010C000000000000F03F0000000000000040#!#1#!#E6100000010C00000000000008400000000000001040
~~END~~


SELECT * FROM YourTable2 ORDER BY PointColumn1.STContains(PointColumn2);
GO
~~START~~
int#!#geometry#!#geometry
1#!#E6100000010C00000000000008400000000000001040#!#E6100000010C00000000000010400000000000001440
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable ORDER BY PointColumn.STContains(@referencePoint);
GO
~~START~~
int#!#geometry
1#!#E6100000010C00000000000000000000000000000000
2#!#E6100000010C00000000000000000000000000000000
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT * FROM YourTable ORDER BY @referencePoint.STContains(PointColumn);
GO
~~START~~
int#!#geometry
1#!#E6100000010C00000000000000000000000000000000
2#!#E6100000010C00000000000000000000000000000000
~~END~~


DECLARE @contains BIT = 1 ;
SELECT ID, PointColumn1.STContains(PointColumn2) AS doContain,
CASE WHEN PointColumn1.STContains(PointColumn2) <= @contains THEN 'Contains' ELSE 'Do_not_contain'
END AS Proximity
FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~START~~
int#!#bit#!#text
1#!#0#!#Contains
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn1.STContains(@referencePoint) AS contain,
CASE WHEN @referencePoint.STContains(PointColumn2) <= @referencePoint.STX THEN 'Contains' ELSE 'Do_not_contain'
END AS Proximity
FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~START~~
int#!#bit#!#text
1#!#0#!#Contains
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
WITH CTE AS ( SELECT ID, PointColumn.STContains(@referencePoint) AS contain FROM YourTable ORDER BY PointColumn.STX)
SELECT * FROM CTE WHERE contain = 1 ORDER BY contain;
GO
~~START~~
int#!#bit
1#!#1
2#!#1
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
WITH CTE AS ( SELECT ID, @referencePoint.STContains(PointColumn) AS contain FROM YourTable ORDER BY PointColumn.STX)
SELECT * FROM CTE WHERE contain = 1 ORDER BY contain;
GO
~~START~~
int#!#bit
1#!#1
2#!#1
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @contains BIT = 1;
SELECT ID, PointColumn.STContains(@referencePoint) AS ReferencePoint,
CASE WHEN PointColumn.STContains(@referencePoint) <= @contains THEN 'contain'
ELSE 'do_not_contain'
END AS Proximity
FROM YourTable;
go
~~START~~
int#!#bit#!#text
1#!#1#!#contain
2#!#1#!#contain
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, @referencePoint.STContains(PointColumn) AS ReferencePoint,
CASE WHEN @referencePoint.STContains(PointColumn) <= @referencePoint.STY THEN 'contain'
ELSE 'do_not_contain'
END AS Proximity
FROM YourTable;
go
~~START~~
int#!#bit#!#text
1#!#1#!#do_not_contain
2#!#1#!#do_not_contain
~~END~~


DECLARE @Ranges TABLE (MinDistance float, MaxDistance float);
INSERT INTO @Ranges VALUES (0, 5), (5, 10), (10, 15);
SELECT * FROM ( SELECT ID,
CASE WHEN PointColumn1.STContains(PointColumn2) BETWEEN 0 AND 1 THEN 'contain'
ELSE 'do_not_contain'
END AS Range
FROM YourTable2
) AS Source
PIVOT ( COUNT(ID) FOR Range IN ([0-5], [5.1-10], [10.1-15], [15.1+])) AS PivotTable;
go
~~ROW COUNT: 3~~

~~START~~
int#!#int#!#int#!#int
0#!#0#!#0#!#0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STContains(@referencePoint) AS contain FROM <YourDatabase>.dbo.YourTable;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '<' at line 2 and character position 67)~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STContains(@referencePoint) AS contain,
JSON_QUERY('{"Contain":' + CAST(PointColumn.STContains(@referencePoint) AS NVARCHAR(MAX)) + '}') AS Json
FROM YourTable;
go
~~START~~
int#!#bit#!#nvarchar
1#!#1#!#{"Contain": 1}
2#!#1#!#{"Contain": 1}
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, @referencePoint.STContains(PointColumn) AS contain,
JSON_QUERY('{"Contain":' + CAST(@referencePoint.STContains(PointColumn) AS NVARCHAR(MAX)) + '}') Json
FROM YourTable;
go
~~START~~
int#!#bit#!#nvarchar
1#!#1#!#{"Contain": 1}
2#!#1#!#{"Contain": 1}
~~END~~


SELECT [PointColumn1].STContains([PointColumn2]) AS contain FROM [YourTable2];
go
~~START~~
bit
0
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @contains BIT = 1;
DECLARE @sql NVARCHAR(MAX);
DECLARE @params NVARCHAR(MAX);
SET @sql = N'
SELECT ID, PointColumn.STContains(@referencePoint) AS EqualityReferencePoint,
CASE WHEN PointColumn.STContains(@referencePoint) <= @contains THEN ''contains''
ELSE ''do_not_contain''
END AS Proximity
FROM YourTable
WHERE PointColumn.STContains(@referencePoint) <= @contains;';
SET @params = N'@referencePoint geometry, @contains float';
EXEC sp_executesql @sql, @params, @referencePoint, @contains;
go
~~START~~
int#!#bit#!#text
1#!#1#!#contains
2#!#1#!#contains
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT PointColumn.STContains(@referencePoint) AS contain FROM YourTable;
SELECT YourTable.PointColumn.STContains(@referencePoint) AS contain FROM YourTable;
SELECT dbo.YourTable.PointColumn.STContains(@referencePoint) AS contain FROM YourTable;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Remote procedure/function reference with 4-part object name is not currently supported in Babelfish)~~



DECLARE @pnt geometry;
SET @pnt = geometry::STGeomFromText('POINT(-122.34900 47.65100)', 4326);
select geometry::Point(@pnt.STY, @pnt.STX, 4326).STContains(@pnt)
DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
DECLARE @contains BIT = 1;
SELECT ROUND(PointColumn.STContains(@referencePoint) / @contains, 0) * @contains AS Grp,
COUNT(*) AS PointCount
FROM YourTable
GROUP BY ROUND(PointColumn.STContains(@referencePoint) / @contains, 0) * @contains
ORDER BY Grp;
GO
~~START~~
bit
0
~~END~~

~~START~~
numeric#!#int
1#!#2
~~END~~


DECLARE @referencePoint geometry = geometry::Point(1.0, 0.0, 4326);
SELECT ROUND(PointColumn.STContains(@referencePoint) / @referencePoint.STX, 0) * @referencePoint.STX AS GRP,
COUNT(*) AS PointCount
FROM YourTable
GROUP BY ROUND(PointColumn.STContains(@referencePoint) / @referencePoint.STX, 0) * @referencePoint.STX
ORDER BY Grp;
GO
~~START~~
float#!#int
0.0#!#2
~~END~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn1.STContains(PointColumn2) AS contain,
cast(PointColumn1.STContains(@referencePoint) as float) - LAG(PointColumn1.STContains(PointColumn2)) OVER (ORDER BY ID) AS Difference 
FROM YourTable2 ORDER BY PointColumn1.STX;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: cannot cast type "bit" to double precision)~~


DECLARE @referencePoint geometry = geometry::Point(0.0, 0.0, 4326);
SELECT ID, PointColumn.STContains(@referencePoint) AS contain,
cast(@referencePoint.STContains(PointColumn) as float) - LAG(@referencePoint.STX) OVER (ORDER BY ID) AS Difference
FROM YourTable ORDER BY PointColumn.STX;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: cannot cast type "bit" to double precision)~~



--for STArea
DECLARE @point geometry;
SET @point = geometry::STPointFromText('POINT(-122.34900 47.65100)', 4326);
SELECT STArea(@point);
go
~~START~~
float
0.0
~~END~~


DECLARE @point geometry;
SET @point = geometry::STPointFromText('POINT(-122.34900 47.65100)', 4326);
SELECT @point.STArea();
Go
~~START~~
float
0.0
~~END~~


DECLARE @point geometry;
SET @point = geometry::POINT(22.34900, -47.65100, 4326);
SELECT @point . STArea ( );
Go
~~START~~
float
0.0
~~END~~


SELECT location.STArea() from SPATIALPOINTGEOM_dt ORDER BY location.STX;
GO
~~START~~
float
<NULL>
0.0
0.0
0.0
0.0
0.0
0.0
~~END~~


DECLARE @point geography;
SET @point = geography::STGeomFromText('POINT(-122.34900 47.65100)', 4326);
SELECT STArea(@point);
SELECT @point.STArea();
Go
~~START~~
float
0.0
~~END~~

~~START~~
float
0.0
~~END~~


DECLARE @point geography;
SET @point = geography::Point(22.34900, -47.65100, 4326);
SELECT STArea(@point);
SELECT @point.STArea();
Go
~~START~~
float
0.0
~~END~~

~~START~~
float
0.0
~~END~~



DECLARE @point1 geometry, @point2 geometry, @point3 geometry;
SET @point1 = geometry::STPointFromText(null, 4326);
SET @point2 = geometry::STGeomFromText(null, 4326);
SET @point3 = geometry::Point(22.34900, -47.65100, 4326);
SELECT @point1.STEquals(@point2);
SELECT @point3.STEquals(@point2);
SELECT @point1.STEquals(@point3);
SELECT @point1.STContains(@point2);
SELECT @point3.STContains(@point2);
SELECT @point1.STContains(@point3);
go
~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~


-- Negative test for Geospatial functions
DECLARE @point1 geometry, @point2 varchar(50), @point3 int;
SET @point1 = geometry::Point(22.34900, -47.65100, 4326);;
SET @point2 = 'Test_String';
SELECT @point1.STEquals(@point2);
SELECT @point1.STContains(@point2);
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: parse error - invalid geometry)~~


-- Null test for Geospatial functions
DECLARE @point1 geography, @point2 geography, @point3 geography;
SET @point1 = geography::STPointFromText(null, 4326);
SET @point2 = geography::STGeomFromText(null, 4326);
SET @point3 = geography::Point(22.34900, -47.65100, 4326);
SELECT @point1.STEquals(@point2);
SELECT @point3.STEquals(@point2);
SELECT @point1.STEquals(@point3);
SELECT @point1.STContains(@point2);
SELECT @point3.STContains(@point2);
SELECT @point1.STContains(@point3);
go
~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~

~~START~~
bit
<NULL>
~~END~~


SELECT location.STArea() from SPATIALPOINTGEOG_dt ORDER BY location.Lat;
GO
~~START~~
float
<NULL>
0.0
0.0
0.0
0.0
0.0
~~END~~

