-- simple vars
declare @i int
declare @j int
set @i = 10
set @j = @i + 10
select @i, @j
GO
~~START~~
int#!#int
10#!#20
~~END~~


declare @i int
declare @j int
select @i = 10, @j = @i + 10
select @i, @j
GO
~~START~~
int#!#int
10#!#20
~~END~~


declare @i int
declare @j int
select @i = 10, @j = @i + 10
select @j += 10
select @i, @j
GO
~~START~~
int#!#int
10#!#30
~~END~~


-- should throw an error
declare @i int 
select @i = 0, @i += 2
select @i
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Babelfish does not support assignment to the same variable in SELECT. variable name: "@i")~~


declare @i int
select @i = 10, @i += 10
select @i
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Babelfish does not support assignment to the same variable in SELECT. variable name: "@i")~~


-- sub-expr
declare @i int
set @i = 10
select @i += (5 - 1)
select @i
GO
~~START~~
int
14
~~END~~


DECLARE @a int
select @a = (select ~cast('1' as int))
select @a
go
~~START~~
int
-2
~~END~~



DECLARE @Counter INT = 1;
DECLARE @MaxValue INT = 10;
WHILE @Counter <= @MaxValue
BEGIN
    DECLARE @IsEven BIT;
    
    IF @Counter % 2 = 0
        SET @IsEven = 1;
    ELSE
        SET @IsEven = 0;
    
    IF @IsEven = 1
        PRINT CAST(@Counter AS VARCHAR(2)) + ' is even';
    ELSE
        PRINT CAST(@Counter AS VARCHAR(2)) + ' is odd';
    
    SET @Counter = @Counter + 1;
END
GO

declare @a numeric (10, 4);
declare @b numeric (10, 4);
SET @a=100.41;
SET @b=200.82;
SELECT @a, @b
select @a+@b as r;
GO
~~START~~
numeric#!#numeric
100.4100#!#200.8200
~~END~~

~~START~~
numeric
301.2300
~~END~~


declare @a numeric;
declare @b numeric (10, 4);
SET @a=100.41;
SET @b=200.82;
SELECT @a, @b
select @a+@b as r;
GO
~~START~~
numeric#!#numeric
100#!#200.8200
~~END~~

~~START~~
numeric
300.8200
~~END~~


declare @a varbinary
set @a = cast('test_bin' as varbinary)
select @a
GO
~~START~~
varbinary
74
~~END~~


declare @a varbinary(max)
set @a = cast('test_bin' as varbinary)
select @a
GO
~~START~~
varbinary
746573745F62696E
~~END~~


declare @a varbinary(10)
set @a = cast('test_bin' as varbinary)
select @a
GO
~~START~~
varbinary
746573745F62696E
~~END~~


DECLARE @a varchar
set @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
1#!#1
~~END~~

~~START~~
varchar
1
~~END~~


DECLARE @v varchar(20);
SELECT @v = NULL;
SELECT ISNUMERIC(@v), LEN(@v), DATALENGTH(@v)
GO
~~START~~
int#!#int#!#int
0#!#<NULL>#!#<NULL>
~~END~~


DECLARE @a varchar(max)
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
35#!#35
~~END~~

~~START~~
varchar
12345678901234567890123456789012345
~~END~~


-- collate can not be used with local variables
DECLARE @v varchar(20) collate BBF_Unicode_CP1_CI_As = 'ci_as';
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'collate' at line 2 and character position 23)~~


declare @source int;
declare @target sql_variant;
select @source = 1.0
select @target = cast(@source as varchar(10));
SELECT sql_variant_property(@target, 'basetype');
select @target
GO
~~START~~
sql_variant
varchar
~~END~~

~~START~~
sql_variant
1
~~END~~


declare @source int;
declare @target varchar(10);
select @source = 1.0
select cast(@source as varchar(10))
select @target = cast(@source as varchar(10));
select @target
GO
~~START~~
varchar
1
~~END~~

~~START~~
varchar
1
~~END~~


DECLARE @a pg_catalog.varchar
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
35#!#35
~~END~~

~~START~~
varchar
12345678901234567890123456789012345
~~END~~


DECLARE @a pg_catalog.varchar(100)
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
35#!#35
~~END~~

~~START~~
varchar
12345678901234567890123456789012345
~~END~~


DECLARE @a pg_catalog.varchar(10)
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
10#!#10
~~END~~

~~START~~
varchar
1234567890
~~END~~


DECLARE @a varchar
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
1#!#1
~~END~~

~~START~~
varchar
1
~~END~~


DECLARE @a varchar(100)
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
35#!#35
~~END~~

~~START~~
varchar
12345678901234567890123456789012345
~~END~~


DECLARE @a varchar(10)
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
10#!#10
~~END~~

~~START~~
varchar
1234567890
~~END~~


DECLARE @a int
set @a = 0
select @a ^= 1
select @a
go
~~START~~
int
1
~~END~~


DECLARE @a int
set @a = 0
select @a += ~@a
select @a
go
~~START~~
int
-1
~~END~~


-- quoted identifiers
declare @v varchar(20) = "ABC", @v2 varchar(20)="XYZ";
select @v += "a""b''c'd", @v2 += "x""y''z";
select @v, @v2
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "abc" does not exist)~~


declare @v varchar(20) = "ABC", @v2 varchar(20)="XYZ";
select @v += "a""b''c'd", @v2 += @v + "x""y''z";
select @v, @v2
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "abc" does not exist)~~


declare @v varchar(20) = "ABC", @v2 varchar(20)="XYZ";
select @v += reverse("a""b''c'd"), @v2 += @v + "x""y''z";
select @v, @v2
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "abc" does not exist)~~


declare @v varchar(20) = "ABC", @v2 varchar(20)="XYZ";
select @v += reverse("a""b''c'd"), @v2 += @v + reverse("x""y''z");
select @v, @v2
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "abc" does not exist)~~


declare @v varchar(20) = "ABC", @v2 varchar(20)="XYZ";
select @v += reverse("a""b''c'd"), @v2 += REVERSE( @v + reverse("x""y''z"));
select @v, @v2
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "abc" does not exist)~~


declare @v varchar(20) = 'ABC', @v2 varchar(20)='XYZ';
select @v += 'abc', @v2 += 'xyz';
select @v, @v2
GO
~~START~~
varchar#!#varchar
ABCabc#!#XYZxyz
~~END~~


declare @a int = 1, @b int = 2;
select @a = 2, @b = @a + 2
select @a, @b
GO
~~START~~
int#!#int
2#!#4
~~END~~


declare @a int = 1, @b int = 2;
select @a += 2, @b -= @a + 2
select @a, @b
GO
~~START~~
int#!#int
3#!#-3
~~END~~


-- xml methods
DECLARE @a bit = 1
DECLARE @xml XML = '<artists> <artist name="John Doe"/> <artist name="Edward Poe"/> <artist name="Mark The Great"/> </artists>'
SELECT @a |= @xml.exist('/artists/artist/@name')
select @a
GO
~~START~~
bit
1
~~END~~


-- test all kind of udts
create type udt from NCHAR
go

declare @a udt
select @a = 'anc'
select @a
GO
~~START~~
nchar
a
~~END~~


DROP type udt 
GO

create type varchar_max from varchar(max)
GO

DECLARE @a varchar_max
SELECT @a = '12345678901234567890123456789012345';
SELECT LEN(@a), DATALENGTH(@a)
SELECT @a
GO
~~START~~
int#!#int
35#!#35
~~END~~

~~START~~
varchar
12345678901234567890123456789012345
~~END~~


DROP type varchar_max
GO

create type num_def from numeric
GO

declare @a numeric;
declare @b num_def;
SET @a=100.41;
SET @b=200.82;
SELECT @a, @b
select @a+@b as r;
GO
~~START~~
numeric#!#numeric
100#!#201
~~END~~

~~START~~
numeric
301
~~END~~


drop type num_def
GO

/*
 * UPDATE test
 */
create table local_var_tst (id int) 
GO

TRUNCATE table local_var_tst
GO

insert into local_var_tst values (1)
insert into local_var_tst values (2)
insert into local_var_tst values (6)
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~






-- declare @i int 
-- update local_var_tst set id =10, @i = id * 5
-- select @i
-- GO
-- select * from local_var_tst;
-- GO
-- -- need to fix this
-- declare @i int 
-- set @i = 0
-- update local_var_tst set id = @i, @i = id * 5
-- select @i
-- GO
-- select * from local_var_tst;
-- GO
-- txn does not affect local variables
begin tran
declare @i int 
update local_var_tst set id = 5, @i = id * 5
select @i
ROLLBACK tran
select @i
GO
~~ROW COUNT: 3~~

~~START~~
int
25
~~END~~

~~START~~
int
25
~~END~~


select * from local_var_tst;
GO
~~START~~
int
1
2
6
~~END~~


TRUNCATE table local_var_tst
GO

insert into local_var_tst values (1)
insert into local_var_tst values (2)
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~


-- should return 4
declare @i int 
select @i = 1
select @i = id * 2 from local_var_tst where id = @i
select @i
GO
~~START~~
int
4
~~END~~


declare @i int 
select @i = 1
select @i = @i + id * 2 from local_var_tst
select @i
GO
~~START~~
int
7
~~END~~


declare @i int 
select @i = 1
select @i = id * 2 + @i from local_var_tst
select @i
GO
~~START~~
int
7
~~END~~


declare @i int 
select @i = 1
select @i += id * 2 from local_var_tst
select @i
GO
~~START~~
int
7
~~END~~


-- 3 parts name 
declare @i int 
select @i = 1
select @i += master.dbo.local_var_tst.id * 2 from local_var_tst
select @i
GO
~~START~~
int
7
~~END~~


-- local var name same as column
declare @id int = 1
select @id += master.dbo.local_var_tst.id * 2 from local_var_tst
select @id
GO
~~START~~
int
7
~~END~~


-- should throw an error
declare @i int
declare @j int
set @i = 10
set @j = 0;
select @i += (select @j = @j + id from local_var_tst)
select @i
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: variable assignment can be used only in top-level SELECT)~~


TRUNCATE table local_var_tst
GO

insert into local_var_tst values (1)
insert into local_var_tst values (2)
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~


declare @i int = 1
declare @j int = 0
select @j += id, @i = id + 1  from local_var_tst where id = @i
select @j
go
~~START~~
int
3
~~END~~


DECLARE @ans INT
SELECT @ans = AVG(id) FROM local_var_tst
select @ans
GO
~~START~~
int
1
~~END~~


-- local variable inside functions
CREATE FUNCTION var_inside_func()
RETURNS INT AS
BEGIN
    DECLARE @ans INT
    SELECT @ans = AVG(id) FROM local_var_tst
    RETURN @ans
END
GO

select var_inside_func();
GO
~~START~~
int
1
~~END~~


DROP FUNCTION var_inside_func();
GO

-- show throw an error
CREATE FUNCTION var_inside_func()
RETURNS @tab table (a int) as
BEGIN
    DECLARE @ans INT
    SELECT @ans += id from local_var_tst
    select @ans
END
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: SELECT statement returning result to a client cannot be used in a function)~~


drop function if exists var_inside_func
go

CREATE FUNCTION var_inside_func()
RETURNS INT AS
BEGIN
    DECLARE @ans INT
    SELECT @ans += id FROM local_var_tst
    RETURN @ans
END
GO

select var_inside_func()
go
~~START~~
int
<NULL>
~~END~~


drop function if exists var_inside_func
go

CREATE FUNCTION var_inside_func()
RETURNS INT AS
BEGIN
    DECLARE @ans INT
    select @ans = 0
    SELECT @ans += id + @ans FROM local_var_tst
    RETURN @ans
END
GO

select var_inside_func()
go
~~START~~
int
4
~~END~~


drop function if exists var_inside_func
go

-- variable with procedure
CREATE PROCEDURE var_with_procedure (@a numeric(10,4) OUTPUT) AS
BEGIN
  SET @a=100.41;
  select @a as a;
END;
GO

exec var_with_procedure 2.000;
GO
~~START~~
numeric
100.4100
~~END~~


-- value of @out should remain 2.000
declare @out numeric(10,4);
set @out = 2.000;
exec var_with_procedure 2.000;
select @out
GO
~~START~~
numeric
100.4100
~~END~~

~~START~~
numeric
2.0000
~~END~~


drop procedure var_with_procedure;
GO

CREATE PROCEDURE var_with_procedure_1 (@a numeric(10,4) OUTPUT, @b numeric(10,4) OUTPUT) AS
BEGIN
  SET @a=100.41;
  SET @b=200.82;
  select @a+@b as r;
END;
GO

EXEC var_with_procedure_1 2.000, 3.000;
GO
~~START~~
numeric
301.2300
~~END~~


-- value of @a should be 100
DECLARE @a INT;
EXEC var_with_procedure_1 @a OUT, 3.000;
SELECT @a;
GO
~~START~~
numeric
301.2300
~~END~~

~~START~~
int
100
~~END~~


drop procedure var_with_procedure_1;
GO

CREATE PROCEDURE var_with_procedure_2
AS
BEGIN
  declare @a int
  declare @b int
  set @a = 1
  return
  select @b=@a+1
END
GO

exec var_with_procedure_2
GO

DROP PROCEDURE var_with_procedure_2
GO

-- insert testing with local variables
truncate table dbo.local_var_tst
go

-- should throw an error
declare @a int = 1
insert into local_var_tst select @a = @a + 1
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: variable assignment can be used only in top-level SELECT)~~


-- syntax error
declare @a int = 1
insert into local_var_tst values (@a = @a + 1)
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '=' at line 3 and character position 37)~~


declare @a int = 1
insert into local_var_tst values (@a + 1)
GO
~~ROW COUNT: 1~~


-- output clause with insert
declare @a int = 1
declare @mytbl table(a int)
insert local_var_tst output inserted.id into @mytbl values (@a + 1) 
select * from @mytbl
GO
~~ROW COUNT: 1~~

~~START~~
int
2
~~END~~


-- output clause with delete
declare @a int = 1
declare @mytbl table(a int)
delete local_var_tst output deleted.id into @mytbl where id = @a + 1
select * from @mytbl
GO
~~ROW COUNT: 2~~

~~START~~
int
2
2
~~END~~


drop table dbo.local_var_tst
go

create table local_var_tst_1 (a int, b int)
GO

insert into local_var_tst_1 values (1,3), (2, 4)
go
~~ROW COUNT: 2~~



-- select test with multi-variable assignment
declare @a int = 0
declare @b int = 0
select @a += a, @b += b from local_var_tst_1
select @a, @b
go
~~START~~
int#!#int
3#!#7
~~END~~


declare @a int = 0
declare @b int = 0
select @a += a, @b += @a + b from local_var_tst_1
select @a, @b
go
~~START~~
int#!#int
3#!#11
~~END~~


declare @a int = 0
declare @b int = 0
select @a += a, @b += @a + ~b from local_var_tst_1
select @a, @b
go
~~START~~
int#!#int
3#!#-5
~~END~~


drop table local_var_tst_1
go

create table local_var_str_tst (id varchar(100))
GO

insert into local_var_str_tst values ('abc'), (' '), ('def')
GO
~~ROW COUNT: 3~~


declare @i varchar(1000)
set @i = ''
select @i = @i + id from local_var_str_tst
select @i
go
~~START~~
varchar
abc def
~~END~~


declare @i varchar(1000)
set @i = ''
select @i = id + @i from local_var_str_tst
select @i
go
~~START~~
varchar
def abc
~~END~~


declare @i varchar(1000)
set @i = ''
select @i += id from local_var_str_tst
select @i
go
~~START~~
varchar
abc def
~~END~~


declare @i varchar(1000)
set @i = ''
select @i = reverse(@i + 'id') from local_var_str_tst
select @i
go
~~START~~
varchar
didiid
~~END~~


declare @i varchar(1000)
set @i = ''
select @i += reverse(id) from local_var_str_tst
select @i
go
~~START~~
varchar
cba fed
~~END~~


declare @i varchar(1000)
set @i = 'abc'
select @i = reverse(@i)
select @i
go
~~START~~
varchar
cba
~~END~~


-- function call like trim, ltrim, etc will be rewritten by ANTLR
declare @i varchar(1000)
set @i = ' '
select @i += id from local_var_str_tst
select len(@i), @i
select @i = trim(@i)
select len(@i), @i
go
~~START~~
int#!#varchar
8#!# abc def
~~END~~

~~START~~
int#!#varchar
7#!#abc def
~~END~~


drop table local_var_str_tst;
go

-- $PARTITION is rewritten by ANTLR
CREATE PARTITION FUNCTION RangePF1 ( INT )  
AS RANGE RIGHT FOR VALUES (10, 100, 1000) ;  
GO

declare @res int = -1;
SELECT @res = $PARTITION.RangePF1 (10);
select @res
select 1 where @res = $PARTITION.RangePF1 (10);
SELECT @res = $PARTITION.RangePF1 (@res);
select @res
GO
~~START~~
int
2
~~END~~

~~START~~
int
1
~~END~~

~~START~~
int
1
~~END~~


DROP PARTITION FUNCTION RangePF1 
GO


CREATE SEQUENCE CountBy1  
    START WITH 1  
    INCREMENT BY 1 ;  
GO  
-- NEXT VALUE FOR gets re-written by ANTLR
DECLARE @myvar1 BIGINT = NEXT VALUE FOR CountBy1  
DECLARE @myvar2 BIGINT ;  
DECLARE @myvar3 BIGINT ;  
select @myvar2 = NEXT VALUE FOR CountBy1 ;  
SELECT @myvar3 = NEXT VALUE FOR CountBy1 ;  
SELECT @myvar1 AS myvar1, @myvar2 AS myvar2, @myvar3 AS myvar3 ;  
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'DECLARE' at line 6 and character position 0)~~


DROP SEQUENCE CountBy1
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: sequence "countby1" does not exist)~~


-- any @@ is also re-written by ANTLR
declare @pid int = 0
select @pid += @@spid
select 1 where @pid = @@spid
go
~~START~~
int
1
~~END~~


-- float point notation also gets rewritten by ANTLR e.g., 2.1E, -.2e+, -2.e-
declare @a float = 0
select @a = 2.1E
select @a
select @a = -.2e+
select @a 
select @a = -2.e-
select @a
go
~~START~~
float
2.1
~~END~~

~~START~~
float
-0.2
~~END~~

~~START~~
float
-2.0
~~END~~

