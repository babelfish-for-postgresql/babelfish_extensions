create table forxml_before_14_7_vu_t1 (id int, a varchar(10));
create table forxml_before_14_7_vu_t2 (id int, a varchar(10));
insert into forxml_before_14_7_vu_t1 values (1, 't1_a1');
insert into forxml_before_14_7_vu_t1 values (2, 't1_a2');
insert into forxml_before_14_7_vu_t1 values (3, NULL);
insert into forxml_before_14_7_vu_t2 values (1, 't2_a1');
insert into forxml_before_14_7_vu_t2 values (2, 't2_a2');
insert into forxml_before_14_7_vu_t2 values (3, NULL);
go
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~


-- Test Select For XML syntax
select * from forxml_before_14_7_vu_t1 for xml auto;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: 'FOR XML AUTO mode' is not currently supported in Babelfish)~~


select * from forxml_before_14_7_vu_t1 for xml raw;
go
~~START~~
ntext
<row id="1" a="t1_a1"/><row id="2" a="t1_a2"/><row id="3"/>
~~END~~


select * from forxml_before_14_7_vu_t1 for xml raw('myrow');
go
~~START~~
ntext
<myrow id="1" a="t1_a1"/><myrow id="2" a="t1_a2"/><myrow id="3"/>
~~END~~


select * from forxml_before_14_7_vu_t1 for xml path;
go
~~START~~
ntext
<row><id>1</id><a>t1_a1</a></row><row><id>2</id><a>t1_a2</a></row><row><id>3</id></row>
~~END~~


select * from forxml_before_14_7_vu_t1 for xml path('myrow');
go
~~START~~
ntext
<myrow><id>1</id><a>t1_a1</a></myrow><myrow><id>2</id><a>t1_a2</a></myrow><myrow><id>3</id></myrow>
~~END~~


select * from forxml_before_14_7_vu_t1 for xml explicit;
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: 'FOR XML EXPLICIT mode' is not currently supported in Babelfish)~~


select * from forxml_before_14_7_vu_t1, forxml_before_14_7_vu_t2 where forxml_before_14_7_vu_t1.id = forxml_before_14_7_vu_t2.id for xml path('myrow');
go
~~START~~
ntext
<myrow><id>1</id><a>t1_a1</a><id>1</id><a>t2_a1</a></myrow><myrow><id>2</id><a>t1_a2</a><id>2</id><a>t2_a2</a></myrow><myrow><id>3</id><id>3</id></myrow>
~~END~~


select * from forxml_before_14_7_vu_t1, forxml_before_14_7_vu_t2 where forxml_before_14_7_vu_t1.id = forxml_before_14_7_vu_t2.id for xml path('myrow'), type;
go
~~START~~
xml
<myrow><id>1</id><a>t1_a1</a><id>1</id><a>t2_a1</a></myrow><myrow><id>2</id><a>t1_a2</a><id>2</id><a>t2_a2</a></myrow><myrow><id>3</id><id>3</id></myrow>
~~END~~


select * from forxml_before_14_7_vu_t1, forxml_before_14_7_vu_t2 where forxml_before_14_7_vu_t1.id = forxml_before_14_7_vu_t2.id for xml path('myrow'), type, root('myroot');
go
~~START~~
xml
<myroot><myrow><id>1</id><a>t1_a1</a><id>1</id><a>t2_a1</a></myrow><myrow><id>2</id><a>t1_a2</a><id>2</id><a>t2_a2</a></myrow><myrow><id>3</id><id>3</id></myrow></myroot>
~~END~~


select * from forxml_before_14_7_vu_t1, forxml_before_14_7_vu_t2 where forxml_before_14_7_vu_t1.id = forxml_before_14_7_vu_t2.id for xml path('myrow'), type, root('myroot'), BINARY BASE64;
go
~~START~~
xml
<myroot><myrow><id>1</id><a>t1_a1</a><id>1</id><a>t2_a1</a></myrow><myrow><id>2</id><a>t1_a2</a><id>2</id><a>t2_a2</a></myrow><myrow><id>3</id><id>3</id></myrow></myroot>
~~END~~


-- Test result format when all values are NULL
select a from forxml_before_14_7_vu_t1 where a is NULL for xml raw;
go
~~START~~
ntext
<row/>
~~END~~


select a from forxml_before_14_7_vu_t1 where a is NULL for xml path;
go
~~START~~
ntext
<row/>
~~END~~


-- Test result format when one value is NULL
select id, a from forxml_before_14_7_vu_t1 where a is NULL for xml raw;
go
~~START~~
ntext
<row id="3"/>
~~END~~


select id, a from forxml_before_14_7_vu_t1 where a is NULL for xml path;
go
~~START~~
ntext
<row><id>3</id></row>
~~END~~


-- Test for xml with order by clause
select * from forxml_before_14_7_vu_t1 order by id for xml raw ('t1');
go
~~START~~
ntext
<t1 id="1" a="t1_a1"/><t1 id="2" a="t1_a2"/><t1 id="3"/>
~~END~~


-- Test for xml with group by
select count(*) as cnt, a from forxml_before_14_7_vu_t1 group by a,id order by id;
go
~~START~~
int#!#varchar
1#!#t1_a1
1#!#t1_a2
1#!#<NULL>
~~END~~

select count(*) as cnt, a from forxml_before_14_7_vu_t1 group by a,id order by id for xml path;
go
~~START~~
ntext
<row><cnt>1</cnt><a>t1_a1</a></row><row><cnt>1</cnt><a>t1_a2</a></row><row><cnt>1</cnt></row>
~~END~~


-- Test for xml in subquery, The subquery is supposed to return only one XML value
select id, (select a from forxml_before_14_7_vu_t2 for xml path) as col from forxml_before_14_7_vu_t1;
go
~~START~~
int#!#ntext
1#!#<row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/>
2#!#<row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/>
3#!#<row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/>
~~END~~


-- Test 2 levels of for xml nesting, with TYPE option
select id, (select a from forxml_before_14_7_vu_t2 for xml path, type) as col from forxml_before_14_7_vu_t1 for xml path, type;
go
~~START~~
xml
<row><id>1</id><col><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col></row><row><id>2</id><col><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col></row><row><id>3</id><col><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col></row>
~~END~~


-- Test 2 levels of for xml nesting, without TYPE option, expect special character escaping
select id, (select a from forxml_before_14_7_vu_t2 for xml path) as col from forxml_before_14_7_vu_t1 for xml path;
go
~~START~~
ntext
<row><id>1</id><col>&lt;row&gt;&lt;a&gt;t2_a1&lt;/a&gt;&lt;/row&gt;&lt;row&gt;&lt;a&gt;t2_a2&lt;/a&gt;&lt;/row&gt;&lt;row/&gt;</col></row><row><id>2</id><col>&lt;row&gt;&lt;a&gt;t2_a1&lt;/a&gt;&lt;/row&gt;&lt;row&gt;&lt;a&gt;t2_a2&lt;/a&gt;&lt;/row&gt;&lt;row/&gt;</col></row><row><id>3</id><col>&lt;row&gt;&lt;a&gt;t2_a1&lt;/a&gt;&lt;/row&gt;&lt;row&gt;&lt;a&gt;t2_a2&lt;/a&gt;&lt;/row&gt;&lt;row/&gt;</col></row>
~~END~~


-- Test 3 levels of for xml nesting with TYPE option
select id, (select id, (select a from forxml_before_14_7_vu_t2 for xml path, type) as col1 from forxml_before_14_7_vu_t1 for xml path, type) as col2 from forxml_before_14_7_vu_t1 for xml path, type;
go
~~START~~
xml
<row><id>1</id><col2><row><id>1</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>2</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>3</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row></col2></row><row><id>2</id><col2><row><id>1</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>2</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>3</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row></col2></row><row><id>3</id><col2><row><id>1</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>2</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row><row><id>3</id><col1><row><a>t2_a1</a></row><row><a>t2_a2</a></row><row/></col1></row></col2></row>
~~END~~


-- Test simple for xml path in procedure
create table forxml_before_14_7_vu_t_employees(
pers_id int,
fname nvarchar(20),
lname nvarchar(20),
sal money);
insert into forxml_before_14_7_vu_t_employees values (1, 'John', 'Johnson', 123.1234);
insert into forxml_before_14_7_vu_t_employees values (2, 'Max', 'Welch', 200.1234);
go
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~


create procedure forxml_before_14_7_vu_p_employee_select as
begin
	select * from forxml_before_14_7_vu_t_employees for xml path;
end;
go

-- Test for xml in procedure with parameters
create procedure forxml_before_14_7_vu_p_employee_select2 @minsal MONEY, @maxsal MONEY as
begin
	select * from forxml_before_14_7_vu_t_employees where sal > @minsal and sal < @maxsal
	for xml path('Employee');
end;
go

-- Test for xml in create view
create view forxml_before_14_7_vu_v1 (col1) as select * from forxml_before_14_7_vu_t1 for xml raw, type;
go

-- Test for xml on pure relational view
create view forxml_before_14_7_vu_v2 (col1, col2) as select * from forxml_before_14_7_vu_t1;
go

-- Test for xml and union all
select a from forxml_before_14_7_vu_t1 UNION ALL select a from forxml_before_14_7_vu_t2 for xml raw ('myrow');
go
~~START~~
ntext
<myrow a="t1_a1"/><myrow a="t1_a2"/><myrow/><myrow a="t2_a1"/><myrow a="t2_a2"/><myrow/>
~~END~~


-- Test invalid syntax when FOR XML is on both sides of UNION ALL, this is SQL Server behavior
select a from forxml_before_14_7_vu_t1 for xml raw ('t1') UNION ALL select a from forxml_before_14_7_vu_t2 for xml raw ('t2');
go
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'UNION' at line 2 and character position 58)~~


-- For xml can access CTE from same query block
create view forxml_before_14_7_vu_v_cte1 as
with cte as (select a from forxml_before_14_7_vu_t1)
select * from cte for xml raw;
go


-- Test for xml and recursive CTE
CREATE TABLE forxml_before_14_7_vu_t_employees2 (
  id serial,
  name varchar(255),
  manager_id int
);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (1, 'Mark', null);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (2, 'John', 1);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (3, 'Dan', 2);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (4, 'Clark', 1);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (5, 'Linda', 2);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (6, 'Willy', 2);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (7, 'Barack', 2);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (8, 'Elen', 2);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (9, 'Kate', 3);
INSERT INTO forxml_before_14_7_vu_t_employees2 VALUES (10, 'Terry', 4);
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ROW COUNT: 1~~


CREATE VIEW forxml_before_14_7_vu_v_with AS
WITH managertree AS (
  SELECT id, name, manager_id
  FROM forxml_before_14_7_vu_t_employees2
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM forxml_before_14_7_vu_t_employees2 e
  INNER JOIN managertree mtree ON mtree.id = e.manager_id
)
SELECT *
FROM managertree mt;
GO

CREATE VIEW forxml_before_14_7_vu_v_with_where AS
WITH managertree AS (
  SELECT id, name, manager_id
  FROM forxml_before_14_7_vu_t_employees2
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM forxml_before_14_7_vu_t_employees2 e
  INNER JOIN managertree mtree ON mtree.id = e.manager_id
)
SELECT *
FROM managertree mt WHERE mt.name = 'Linda' FOR XML RAW ('managertree');
GO

-- BABEL-1178, data type of variable is lost during variable binding in FORMAT
-- function
create procedure forxml_before_14_7_vu_p_datalength @pid int as
declare @a int, @b smallint;
set @a = 1;
set @b = 1;
select a, datalength(@a), datalength(@b) from forxml_before_14_7_vu_t1 where id = @pid for xml raw;
go

-- test string variable can be binded with for xml query
create procedure forxml_before_14_7_vu_p_strvar @pid int, @str varchar(10) as
select * from forxml_before_14_7_vu_t1 where id = @pid and a = @str for xml raw;
go
